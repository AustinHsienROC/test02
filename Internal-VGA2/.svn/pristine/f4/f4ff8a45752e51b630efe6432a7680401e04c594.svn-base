#ifdef _WIN32
  #include "stdafx.h"
#else
  #include "GlobalTypes.h"
#endif
#include <string.h>
#include "Patches.h"
#include "CTA_Def.h"

//******************************************************************************
// S T A T I C   F U N C T I O N   P R O T O T Y P E S
//******************************************************************************

//******************************************************************************
// M A C R O   D E F I N I T I O N S
//******************************************************************************
Patches* Patches::instance = NULL;

//******************************************************************************
// F U N C T I O N   B O D Y S
//******************************************************************************
//檢查點(x,y)是否在框內
inline BOOL Patches::IsInCandRect(CONST INT16 x,CONST INT16 y, CONST CandidateRec* CTACandidate )
{
	return ( x>=CTACandidate->startxi && x<CTACandidate->startxi+CTACandidate->width &&
		y>=CTACandidate->startyi && y<CTACandidate->startyi+CTACandidate->height);
}
/**
* @brief           回傳 無使用的 CTACandidate Index (ex.LabelCount=7 , return 15, 
* @n               means new a CTACandidate[15].GroupID = 8)
* @param[in]       CTACandidate Rectangle candidate
* @param[in,out]   LabelCount   Group ID
* @return          new CTACandidate idx
*/
INT16 Patches::GetNewGroupID( CandidateRec CTACandidate[] , UINT16* LabelCount )
{
	for( INT32 i=0 ; i < MAXCandidateNum; i++)
	{
		if( 0 == CTACandidate[i].GroupID ) // Find the un-used CTACandidate.
		{
			if( LabelCount!=NULL )         //assign the new GroupID for new candidates
				CTACandidate[i].GroupID = ++(*LabelCount);
			return i;
		}
	}
	return -1;
}

inline INT16 Patches::FindLREdgePoint(CandidateRec CTACandidatePrev[],CONST INT16 i,CONST CHAR Dir,CONST UCHAR* img_SblEdgePrev,BOOL &foundLRedge,INT16 &leftPos,INT16 &rightPos)
{
	CONST INT16 sampleHeight=CTACandidatePrev[i].height*2/3;//height in the white rectangle (0~height-1)
	CONST INT16 edgeValueTH=80;
	CONST INT16 edgeCountTH=10;
	
	INT32 idx;
	INT16 minEdgeX=SrcImg_W,maxEdgeX=0;
	INT16 j;
	//	Rect_t ROI_edge; 

#pragma region //========Find edge point=======
	idx=(CTACandidatePrev[i].startyi+sampleHeight)*SrcImg_W+CTACandidatePrev[i].startxi;
	for(j=0; j<CTACandidatePrev[i].width; j++,idx++)
	{
		if(img_SblEdgePrev[idx]>edgeValueTH)//1.find left/right edge point at specified height in the rectangle
		{
			maxEdgeX=MAX(maxEdgeX,j);
			minEdgeX=MIN(minEdgeX,j);
			foundLRedge=TRUE;
		}
	}
	if(foundLRedge)
	{
		leftPos=CTACandidatePrev[i].startxi+minEdgeX;
		rightPos=CTACandidatePrev[i].startxi+maxEdgeX;
	}
#pragma endregion //========Find edge point=======
	
	return sampleHeight;
}

//assign bottom corner to CTACandidatePrev[i]
inline void Patches::FindBottomCorner(CandidateRec CTACandidatePrev[], CONST INT16 i, CONST CHAR Dir, 
                                      CONST UCHAR *harrisMapPrev, CONST HarrisCornerPos *harrisCornersPrev, CONST HarrisCornerPos2 *harrisCorners2Prev, 
                                      TARGET_NUM *pTargetNum, BOOL &foundLeftCorner,BOOL &foundRightCorner)
{
	INT16 j;
	Rect_t ROI_bottomLeft, ROI_bottomRight;

#pragma region //========Find bottom corner=======
	ROI_bottomLeft.start_col=CTACandidatePrev[i].startxi;
	ROI_bottomLeft.start_row=CTACandidatePrev[i].startyi+(CTACandidatePrev[i].height>>1);
	ROI_bottomLeft.width=(CTACandidatePrev[i].width>>1);
	ROI_bottomLeft.height=(CTACandidatePrev[i].height>>1);
	ROI_bottomRight.start_col=CTACandidatePrev[i].startxi+(CTACandidatePrev[i].width>>1);
	ROI_bottomRight.start_row=ROI_bottomLeft.start_row;//CTACandidatePrev[i].startyi+(CTACandidatePrev[i].height>>1);
	ROI_bottomRight.width=(CTACandidatePrev[i].width>>1);
	ROI_bottomRight.height=ROI_bottomLeft.height;//(CTACandidatePrev[i].height>>1);
/*	
	if(Dir=='R')
	{
		if( CTACandidatePrev[i].ObjMoveXY[0]<0 && 
			CTACandidatePrev[i].boundaryType!=noBound &&
			CTACandidatePrev[i].isInReviveMode!=No_Tracking)
			ROI_bottomLeft.width=MAX(0,CTACandidatePrev[i].ObjTrackPos[0]-CTACandidatePrev[i].startxi);
	}
	else//Dir=='L'
	{	
		if( CTACandidatePrev[i].ObjMoveXY[0]>0 && 
			CTACandidatePrev[i].boundaryType!=noBound &&
			CTACandidatePrev[i].isInReviveMode!=No_Tracking)
			ROI_bottomLeft.width=MAX(0,CTACandidatePrev[i].ObjTrackPos[0]-CTACandidatePrev[i].startxi);
	}
*/
	CONST INT16 bottomLeft_x=ROI_bottomLeft.start_col;
	CONST INT16 bottomLeft_y=ROI_bottomLeft.start_row+ROI_bottomLeft.height;
	CONST INT16 bottomRight_x=ROI_bottomRight.start_col+ROI_bottomRight.width;
	CONST INT16 bottomRight_y=ROI_bottomRight.start_row+ROI_bottomRight.height;

	INT16 bottomLeftValue=9999,bottomRightValue=9999; 
	INT16 bL,bR;

	//for(j=0; j<harrisCorners2Prev->total_points; j++)
    for(j=0; j<pTargetNum->FeaturePtNumPrev; j++)
	{
		if( !harrisCorners2Prev[j].isValid )
			continue;
		
		//search & assign bottomLeft corner
		if(IsInRect(harrisCornersPrev[j].x,harrisCornersPrev[j].y,&ROI_bottomLeft))
		{
			bL=(harrisCornersPrev[j].x-bottomLeft_x)+(bottomLeft_y-harrisCornersPrev[j].y);
			if(bL<bottomLeftValue)
			{
				foundLeftCorner=TRUE;
				bottomLeftValue=bL;
				CTACandidatePrev[i].BottomLeftCorner[0]=harrisCornersPrev[j].x;
				CTACandidatePrev[i].BottomLeftCorner[1]=harrisCornersPrev[j].y;
			}
		}
		//search & assign bottomRight corner
		if(IsInRect(harrisCornersPrev[j].x,harrisCornersPrev[j].y,&ROI_bottomRight))
		{
			bR=(bottomRight_x-harrisCornersPrev[j].x)+(bottomRight_y-harrisCornersPrev[j].y);
			if(bR<bottomRightValue)
			{
				foundRightCorner=TRUE;
				bottomRightValue=bR;
				CTACandidatePrev[i].BottomRightCorner[0]=harrisCornersPrev[j].x;
				CTACandidatePrev[i].BottomRightCorner[1]=harrisCornersPrev[j].y;
			}
		}
	}
#pragma endregion //========Find bottom corner=======
}

inline BOOL Patches::IsInRect(CONST INT16 x,CONST INT16 y, CONST Rect_t* ROI )
{    
	return ( x>=ROI->start_col && x<ROI->start_col+ROI->width &&
		y>=ROI->start_row && y<ROI->start_row+ROI->height);
}

//************************************
// Method:    EdgeTracking  最後一步 當t-1 object tracking中斷 強制在t 找出對應的candidate
// FullName:  Point_Track::EdgeTracking
// Access:    public 
// Returns:   void
// Qualifier:
// Parameter: CandidateRec CTACandidate[]
// Parameter: CandidateRec CTACandidatePrev[]
// Parameter: UCHAR * Sbl_img
// Parameter: UCHAR * Sbl_imgPrev
// Parameter: UCHAR * FD_Binary  Frame Differnece
// Parameter: UINT16 & LabelCount: 目前已經用到的label# (starts from 1)
//************************************
UINT8 Patches::EdgeTracking( CandidateRec CTACandidate[], CandidateRec CTACandidatePrev[], CONST INT32 Region[4], CONST CHAR Dir, 
                             CONST UCHAR* img_track, CONST UCHAR* img_trackPrev, CONST UCHAR* img_SblEdgePrev,CONST UCHAR *harrisMapPrev, 
                             CONST HarrisCornerPos *harrisCornersPrev, CONST HarrisCornerPos2 *harrisCorners2Prev, TARGET_NUM *pTargetNum,
                             CONST INT16 THD_retrieveObj[4], INT16 &inMaxCand,INT16 inMaxCandPrev , INT32 imgDimensionX )
{
	CONST INT16 TH_boundary[2]={5,20};//frames that obj keeps at the boundary {static condition, has moving}
	CONST INT16 TH_horiSpeed=5;//horizontal speed TH of the Obj
	CONST FLOAT TH_horiCornerMove=0.2;//horizontal displacement TH of Corner
	CONST INT16 TH_staticAppearCounter[2]={3,20};//how long the static car will be removed
	CONST INT16 TH_moveDirAppearCounter=10;//how long the searching direction of existed car will be locked
	CONST INT16 TH_boundRectangleWidth=(INT16)(0.4*(Region[2]-Region[0]));//if width of obj < the Value, boundaryCount is activated
    CONST INT16 TH_minRectangleWidth  = ROISegBlockH+20   ; ///< min acceptable width for boundary obj
    CONST INT16 TH_minRectangleHeight = ROISegBlockV+10   ; ///< min acceptable height for boundary obj
	CONST INT16 TH_failEdge         = THD_retrieveObj[2] ; //max EdgeTracking times

//	static BOOL regionOccupy_L=false, regionOccupy_R=false; //flag: there is an obj moving across L/R ROI

	//moveDir 
	//	2 5 1
	// 3 0 4
	//	3 7 4
	//UCHAR moveDirPrev;
	UCHAR moveDir;
	INT16 boundaryCountTH=TH_boundary[1];
	INT16 CarHeadXY[2];
    INT16 startxi;
    INT16 startyi;
    INT16 width;
    INT16 height;
    INT16 candIdx;
    INT16 moveX,moveY;
	UINT8 ret=0;
	INT16 i;

	BOOL updateTrackMoveOnly;
	INT16 candLink;

	INT16 preCanIndex=inMaxCandPrev;
	INT16 candMaxIndex=inMaxCand; 
    
	for ( i = 0 ; i < preCanIndex ; ++i) 
    {
        if( Valid != CTACandidatePrev[i].isValid )
            continue;
        if(CTACandidatePrev[i].retrieveEdgeTimes>=TH_failEdge )
            continue;
		if(CTACandidatePrev[i].staticCounter>=TH_staticAppearCounter[0])//不追蹤連續靜止車輛//
			continue;

		if ( TRUE == CTACandidatePrev[i].isRelatedCandValid )
		{
			updateTrackMoveOnly=TRUE;
			candLink=CTACandidatePrev[i].relatedCandLink;
		}
		else
		{
			updateTrackMoveOnly=FALSE;
//			candLink=-1;
		}
/*		
		INT16 corn_minDir=99,corn_maxDir=-1,corn_avgCount=0;
		for(j=0; j<4; j++)//calculate direction of motion corner
		{
			corn_minDir=MIN(corn_minDir,CTACandidatePrev[i].CornerVector[j]);
			corn_maxDir=MIN(corn_maxDir,CTACandidatePrev[i].CornerVector[j]);
			corn_avgCount+=CTACandidatePrev[i].CornerVector[j];
		}
*/
			if(Dir=='L')
			{
				if(CTACandidatePrev[i].width<=TH_minRectangleWidth)
			if(CTACandidatePrev[i].boundaryType==rightBound)//&& CTACandidatePrev[i].avgObjMoveXY_w[0]>0) //boundary small obj is not tracked
				continue;
				if(CTACandidatePrev[i].CornerMove[0]<-TH_horiCornerMove && CTACandidatePrev[i].ObjSpeedXY[0]<-TH_horiSpeed)//obj moving away is not tracked
					continue;
			}
			else//Dir=='R'
			{
				if(CTACandidatePrev[i].width<=TH_minRectangleWidth)
			if(CTACandidatePrev[i].boundaryType==leftBound) //&& CTACandidatePrev[i].avgObjMoveXY_w[0]<0) //boundary small obj is not tracked
					continue;
				if(CTACandidatePrev[i].CornerMove[0]>TH_horiCornerMove && CTACandidatePrev[i].ObjSpeedXY[0]>TH_horiSpeed)//obj moving away is not tracked
				continue;
			}

//		if( (CTACandidatePrev[i].boundaryType==upperBound || CTACandidatePrev[i].boundaryType==lowerBound) &&
//			  CTACandidatePrev[i].height<=TH_minRectangleHeight )
//			continue;


#pragma region //========Update Prev Tracking Position=========
/*
		CONST INT16 maxLength=CTACandidatePrev[i].width*CTACandidatePrev[i].height;
		INT16 length=0;
		INT8 vx=0,vy=0;
		INT16 coordX,coordY;
		
		TRACK->SpiralOrder(vx,vy,TRUE);//initial 

//		if(CTACandidatePrev[i].isInReviveMode!=No_Tracking)
		if(CTACandidatePrev[i].ObjTrackPos[0]!=0 || CTACandidatePrev[i].ObjTrackPos[1]!=0)
		{
			while(length<maxLength)
			{
				length=TRACK->SpiralOrder(vx,vy);
				if(Dir=='L' && vx<0 && vy<0)//the second quadrant is not considered
				{
//					if(CTACandidatePrev[i].avgObjMoveXY_w[0]>0)//moving right
						continue;
				}
				else if(Dir=='R' && vx>0 && vy<0)//the first quadrant is not considered
				{
//					if(CTACandidatePrev[i].avgObjMoveXY_w[0]<0)//moving left
						continue;
				}

				coordX=CTACandidatePrev[i].ObjTrackPos[0]+vx;
				coordY=CTACandidatePrev[i].ObjTrackPos[1]+vy;
				if(! IsInCandRect(coordX,coordY,&CTACandidatePrev[i]))//must in the rectangle
					continue;

				idx=coordY*SrcImg_W+coordX;
				if(harrisMapPrev[idx]>0)
				{
					CTACandidatePrev[i].ObjTrackPos[0]=coordX;//update tracking point to corner point in the neighbor
					CTACandidatePrev[i].ObjTrackPos[1]=coordY;
					break;
				}
			}
		}
*/
#pragma endregion //========Update Prev Tracking Position=========

#pragma region //========Select Tracking Position=========

        CONST INT16 maskWidth   = ROISegBlockH;
        CONST INT16 maskHeight  = ROISegBlockV;
        CONST INT32 th_array[4] = { /*TRACK->p_th_array[0]*maskWidth*maskHeight/MATCH_BLOCK_WIDTH/MATCH_BLOCK_HEIGHT*/99999,-999,-999,20};

		INT16 leftPos=0,rightPos=0;//position of edge point at Left/Right of the rectangle, will be updated
		BOOL foundLeftCorner=FALSE,foundRightCorner=FALSE;//flag: is the left-bottom/right-bottom corner found, will be updated
		BOOL foundLRedge=FALSE;//flag: is the left/right point found, will be updated
		INT16 sampleHeight;//will be updated

        UCHAR src_msk[ maskWidth * maskHeight ];
        UCHAR dst_msk[ maskWidth * maskHeight ];
        MVector_t mv_sum={0,0};			        ///< Motion vector value at( corner_x, corner_y)

		if(Dir=='R')
		{
			if( CTACandidatePrev[i].boundaryType==leftBound || CTACandidatePrev[i].boundaryType==lowerBound )//L: left/bottom boundary
			{
#if ON==DBG_INFO
				//DumpValueToText("g_Sobel_imgPrev.txt",0,160,170,300,SrcImg_W,img_SblEdgePrev);
#endif
				if(CTACandidatePrev[i].boundaryCount>=2 && CTACandidatePrev[i].isInReviveMode!=No_Tracking)//use previous tracking point
				{
					CarHeadXY[0]=CTACandidatePrev[i].ObjTrackPos[0];
					CarHeadXY[1]=CTACandidatePrev[i].ObjTrackPos[1];
				}
				else if(IsInCandRect(CTACandidatePrev[i].ObjPosxy[0],CTACandidatePrev[i].ObjPosxy[1],&CTACandidatePrev[i]))//use car head point
				{
					CarHeadXY[0]=CTACandidatePrev[i].ObjPosxy[0];
					CarHeadXY[1]=CTACandidatePrev[i].ObjPosxy[1];
				}
				else //default position
                {
					sampleHeight=FindLREdgePoint(CTACandidatePrev,i,Dir,img_SblEdgePrev,foundLRedge,leftPos,rightPos);
					if(foundLRedge)
					{
                        CarHeadXY[0]=rightPos;//use edge point at the right most of the center row 
                        CarHeadXY[1]=CTACandidatePrev[i].startyi+sampleHeight;
                    }
					else
					{
						CarHeadXY[0]=CTACandidatePrev[i].startxi+CTACandidatePrev[i].width-1;//use grid 6 in 9-grid-zone as tracking point
						CarHeadXY[1]=CTACandidatePrev[i].startyi+(CTACandidatePrev[i].height>>1);
					}
                }
			}
			else if(CTACandidatePrev[i].boundaryType==rightBound && CTACandidatePrev[i].width<100)//R: right boundary
			{
				FindBottomCorner(CTACandidatePrev,i,Dir,harrisMapPrev,harrisCornersPrev, harrisCorners2Prev, pTargetNum, foundLeftCorner,foundRightCorner);

				if(foundLeftCorner)//use corner
				{
					CarHeadXY[0]=CTACandidatePrev[i].BottomLeftCorner[0];
					CarHeadXY[1]=CTACandidatePrev[i].BottomLeftCorner[1];
				}
				else
				{
					CarHeadXY[0]=CTACandidatePrev[i].startxi;//use left-bottom of the rectangle as tracking point
					CarHeadXY[1]=CTACandidatePrev[i].startyi + CTACandidatePrev[i].height-1;
				}
			}
			else//R: typical case
			{
/*				if(endyi<172)
				{
					CarHeadXY[0]=CTACandidatePrev[i].startxi;//use left-bottom of the rectangle as tracking point
					CarHeadXY[1]=CTACandidatePrev[i].startyi + CTACandidatePrev[i].height-1;
				}
				else
*/				{
					if(CTACandidatePrev[i].isInReviveMode!=No_Tracking)//use previous tracking point
					{
						CarHeadXY[0]=CTACandidatePrev[i].ObjTrackPos[0];
						CarHeadXY[1]=CTACandidatePrev[i].ObjTrackPos[1];
					}
					else if(IsInCandRect(CTACandidatePrev[i].ObjPosxy[0],CTACandidatePrev[i].ObjPosxy[1],&CTACandidatePrev[i]))//use car head as tracking point
					{
						CarHeadXY[0]=CTACandidatePrev[i].ObjPosxy[0];
						CarHeadXY[1]=CTACandidatePrev[i].ObjPosxy[1];
					}
					else
					{
						FindBottomCorner(CTACandidatePrev,i,Dir,harrisMapPrev,harrisCornersPrev, harrisCorners2Prev, pTargetNum, foundLeftCorner,foundRightCorner);

						if(foundLeftCorner)//use corner as tracking point(以下皆為default)
					{
						CarHeadXY[0]=CTACandidatePrev[i].BottomLeftCorner[0];
						CarHeadXY[1]=CTACandidatePrev[i].BottomLeftCorner[1];
					}
					else if(foundRightCorner)
					{
						CarHeadXY[0]=CTACandidatePrev[i].BottomRightCorner[0];
						CarHeadXY[1]=CTACandidatePrev[i].BottomRightCorner[1];
					}
					else
					{
						CarHeadXY[0]=CTACandidatePrev[i].startxi + (CTACandidatePrev[i].width>>1);//use grid 8 in 9-grid-zone as tracking point
						CarHeadXY[1]=CTACandidatePrev[i].startyi + CTACandidatePrev[i].height-1;
//						CarHeadXY[1]=CTACandidatePrev[i].startyi + (CTACandidatePrev[i].height>>1);
					}
				}
			}
		}
		}
		else//********************************** Dir=='L' **********************************************
		{
			if( CTACandidatePrev[i].boundaryType==rightBound || CTACandidatePrev[i].boundaryType==lowerBound )//L: right/bottom boundary case
			{
				if(CTACandidatePrev[i].boundaryCount>=2 && CTACandidatePrev[i].isInReviveMode!=No_Tracking)
				{
					CarHeadXY[0]=CTACandidatePrev[i].ObjTrackPos[0];
					CarHeadXY[1]=CTACandidatePrev[i].ObjTrackPos[1];
				}
				else if(IsInCandRect(CTACandidatePrev[i].ObjPosxy[0],CTACandidatePrev[i].ObjPosxy[1],&CTACandidatePrev[i]))//use car head
				{
					CarHeadXY[0]=CTACandidatePrev[i].ObjPosxy[0];
					CarHeadXY[1]=CTACandidatePrev[i].ObjPosxy[1];
				}
				else //default position
                {				
					sampleHeight=FindLREdgePoint(CTACandidatePrev,i,Dir,img_SblEdgePrev,foundLRedge,leftPos,rightPos);
					if(foundLRedge)
					{
                    CarHeadXY[0]=leftPos;//以白框中央最左方的edge點當作追蹤點
                    CarHeadXY[1]=CTACandidatePrev[i].startyi+sampleHeight;
                }
					else
					{
						CarHeadXY[0]=CTACandidatePrev[i].startxi;//以白框左方中央當作追蹤點
						CarHeadXY[1]=CTACandidatePrev[i].startyi+(CTACandidatePrev[i].height>>1);
					}
                }
			}
			else if(CTACandidatePrev[i].boundaryType==leftBound && CTACandidatePrev[i].width<100)//L:左邊緣
			{
				FindBottomCorner(CTACandidatePrev,i,Dir,harrisMapPrev,harrisCornersPrev, harrisCorners2Prev, pTargetNum, foundLeftCorner,foundRightCorner);
				if(foundRightCorner)//以corner當作追蹤點
				{
					CarHeadXY[0]=CTACandidatePrev[i].BottomRightCorner[0];
					CarHeadXY[1]=CTACandidatePrev[i].BottomRightCorner[1];
				}
				else
				{
					CarHeadXY[0]=CTACandidatePrev[i].startxi+ CTACandidatePrev[i].width-1;//以白框右下角當作追蹤點
					CarHeadXY[1]=CTACandidatePrev[i].startyi + CTACandidatePrev[i].height-1;
				}
			}
			else//L:一般狀況
			{
/*				if(endyi<172)
				{
					CarHeadXY[0]=CTACandidatePrev[i].startxi+CTACandidatePrev[i].width-1;//以白框右下角當作追蹤點
					CarHeadXY[1]=CTACandidatePrev[i].startyi + CTACandidatePrev[i].height-1;
				}
				else
*/				{
					if(CTACandidatePrev[i].isInReviveMode!=No_Tracking)//以前一次結果當追蹤點
					{
						CarHeadXY[0]=CTACandidatePrev[i].ObjTrackPos[0];
						CarHeadXY[1]=CTACandidatePrev[i].ObjTrackPos[1];
					}
					else if(IsInCandRect(CTACandidatePrev[i].ObjPosxy[0],CTACandidatePrev[i].ObjPosxy[1],&CTACandidatePrev[i]))//以車頭當作追蹤點
					{
						CarHeadXY[0]=CTACandidatePrev[i].ObjPosxy[0];
						CarHeadXY[1]=CTACandidatePrev[i].ObjPosxy[1];
					}
					else
					{
						FindBottomCorner(CTACandidatePrev,i,Dir,harrisMapPrev,harrisCornersPrev,harrisCorners2Prev,pTargetNum, foundLeftCorner,foundRightCorner);
						if(foundRightCorner)//以corner當作追蹤點(以下皆為default)
					{
						CarHeadXY[0]=CTACandidatePrev[i].BottomRightCorner[0];
						CarHeadXY[1]=CTACandidatePrev[i].BottomRightCorner[1];
					}
					else if(foundLeftCorner)//以corner當作追蹤點
					{
						CarHeadXY[0]=CTACandidatePrev[i].BottomLeftCorner[0];
						CarHeadXY[1]=CTACandidatePrev[i].BottomLeftCorner[1];
					}
					else
					{
						CarHeadXY[0]=CTACandidatePrev[i].startxi + (CTACandidatePrev[i].width>>1);//以白框下方中央當作追蹤點
						CarHeadXY[1]=CTACandidatePrev[i].startyi + CTACandidatePrev[i].height-1;
					}
				}
			}
		}
		}
#pragma endregion========Select Tracking Position=========
		///////////////////////////////////////////////////////////////////////////////

#if 0 //find edge of car body
		//edge的使用可參考CandidateLocate(.)
		INT16 col_sum[SrcImg_W];
		INT16 col_width;
		UINT32 max_sum=0,sum=0;
		INT16 max_row=0,max_col=0;
		INT32 idx,idx_start;
		INT16 k;
		memset(col_sum,0,sizeof(col_sum));
		idx_start=CTACandidatePrev[i].startyi*SrcImg_W+CTACandidatePrev[i].startxi;
		for(k=0; k<CTACandidatePrev[i].height; k++,idx_start+=SrcImg_W)
		{
			sum=0;
			for(j=0, idx=idx_start; j<CTACandidatePrev[i].width; j++,idx++)
			{
				col_sum[j]
				sum+=img_edge[idx];
			}
			if(max_sum<sum)
			{
				max_sum=sum;
				max_col=j+CTACandidatePrev[i].startxi;
			}
		}
#endif

#pragma region                //========Car Head Motion Estimation=========
		//moveDirPrev=CTACandidatePrev[i].moveDir;

 /*      mv_sum = TRACK->ME_Hexagon_Search_iterative(img_track , img_trackPrev, SrcImg_W,               //Img
            CarHeadXY[0] , CarHeadXY[1],//PointPosition
            0,0,                                                                            //PointPosition
            maskWidth , maskHeight,
            (maskWidth*maskHeight),
            TRACK->MATCH_SHIFT_BIT , th_array,
            src_msk, dst_msk);
*/		
/*		mv_sum = TRACK->ME_BBGDS_Search(img_track , img_trackPrev, SrcImg_W, //Img
            CarHeadXY[0] , CarHeadXY[1],     //PointPosition
           CarHeadXY[0] , CarHeadXY[1],     //PointPosition
            maskWidth , maskHeight,
           (maskWidth*maskHeight),
            TRACK->MATCH_SHIFT_BIT , th_array,
            src_msk, dst_msk);
*/
        mv_sum = TRACK->ME_Full_Search_Spiral( img_track , img_trackPrev ,NULL, SrcImg_W,         //Img
            CarHeadXY[0] , CarHeadXY[1],   //PointPosition
            maskWidth , maskHeight,
            (maskWidth*maskHeight),
            TRACK->MATCH_SHIFT_BIT, th_array,
            src_msk, dst_msk, CTACandidatePrev[i].moveDir);//加入moveDirPrev限制MV方向

        moveX = (mv_sum.x==e_mv_invalid)? ROUND(CTACandidatePrev[i].ObjMovexy[0]) : mv_sum.x;
        moveY = (mv_sum.y==e_mv_invalid)? ROUND(CTACandidatePrev[i].ObjMovexy[1]) : mv_sum.y;
		moveDir=CTACandidatePrev[i].moveDir;//moveDirPrev;

			if(Dir=='L')
		{
			if(moveX==0 && moveY==0)//solve: 車子開到另一側, 追蹤框遺留在原側--
				if(CTACandidatePrev[i].boundaryType==rightBound)// || CTACandidatePrev[i].boundaryType==upperBound )
				boundaryCountTH=TH_boundary[0];
			if(moveX<0 && CTACandidatePrev[i].ObjTrackMove[0]<0)//遠離車輛不追蹤--
			{
				if(updateTrackMoveOnly)
				{
					moveDir=3;
					CTACandidate[ candLink].IsSuppress = Forbidden; 
				}
				else
				continue;
			}
			if(CTACandidatePrev[i].appearCounter>=TH_moveDirAppearCounter)
			if(moveX>0 && CTACandidatePrev[i].ObjTrackMove[0]>0)//靠近車輛鎖定追蹤方向
				moveDir=4;
		}
		else//Dir=='R'
		{
			if(moveX==0 && moveY==0)
				if(CTACandidatePrev[i].boundaryType==leftBound)// || CTACandidatePrev[i].boundaryType==upperBound )
				boundaryCountTH=TH_boundary[0];
			if(moveX>0 && CTACandidatePrev[i].ObjTrackMove[0]>0)//遠離車輛不追蹤
			{
				if(updateTrackMoveOnly)
				{
					moveDir=4;
					CTACandidate[ candLink].IsSuppress = Forbidden; 
				}
				else
				continue;
			}
			if(CTACandidatePrev[i].appearCounter>=TH_moveDirAppearCounter)
			if(moveX<0 && CTACandidatePrev[i].ObjTrackMove[0]<0)//靠近車輛鎖定追蹤方向
				moveDir=3;
		}
		if(CTACandidatePrev[i].boundaryCount>=boundaryCountTH && CTACandidatePrev[i].width<TH_boundRectangleWidth)//solve: 追蹤框逗留太久
			continue;

		candIdx=-1;
		if(updateTrackMoveOnly==FALSE)
		{
#pragma endregion //========Car Head Motion Estimation=========
			INT16 endxi;
			INT16 endyi;
              //===========edge tracking ============
        startxi = CTACandidatePrev[i].startxi + moveX;
        startyi = CTACandidatePrev[i].startyi + moveY;
        endxi   = CTACandidatePrev[i].startxi + CTACandidatePrev[i].width  + moveX;
        endyi   = CTACandidatePrev[i].startyi + CTACandidatePrev[i].height + moveY;

        startxi = MAX_MIN_RANGE(startxi,Region[0],Region[2]);
        startyi = MAX_MIN_RANGE(startyi,Region[1],Region[3]);
        endxi   = MAX_MIN_RANGE(endxi,Region[0],Region[2]);
        endyi   = MAX_MIN_RANGE(endyi,Region[1],Region[3]);
        width   = MAX( endxi-startxi , 0 );
        height  = MAX( endyi-startyi , 0 );

        // 當框接觸ROI邊緣且變小時
        if( width <= TH_minRectangleWidth )
        {
            if(( Dir=='R' && startxi <= Region[0] ) || (Dir=='L' && endxi>=Region[2]))
                continue;
        }
        if( height <= TH_minRectangleHeight)
        {
            if(endyi>=Region[3])
                continue;
        }

        candIdx = GetNewGroupID( CTACandidate );
        if( -1 == candIdx) continue;

        CTACandidate[candIdx]                    = CTACandidatePrev[i]; //copy
		//CTACandidate[candIdx].GroupID        = 0;
        CTACandidate[candIdx].startxi            = startxi;
        CTACandidate[candIdx].startyi            = startyi;
        CTACandidate[candIdx].width              = width;
        CTACandidate[candIdx].height             = height;
		CTACandidate[candIdx].size               = CTACandidate[candIdx].width*CTACandidate[candIdx].height;

		CTACandidate[candIdx].isValid            = Valid;
		CTACandidate[candIdx].relatedCandLink    = i;
		CTACandidate[candIdx].isRelatedCandValid = Valid;
//		CTACandidate[candIdx].boundaryCount    = CTACandidatePrev[i].boundaryCount;
//		CTACandidate[candIdx].boundaryType    = CTACandidatePrev[i].boundaryType;
//      CTACandidate[candIdx].countDown          = CTACandidatePrev[i].countDown;
//		CTACandidate[candIdx].appearCounter=CTACandidatePrev[i].appearCounter;
			CTACandidate[candIdx].isInReviveMode  =  PureTracking;

//調整retrieveEdgeTimes//20141210 spike:僅spatial上的比對,其實需要temporal上的
#if 0

		if(CTACandidatePrev[i].avgObjMoveXY_w[1]<0 && CTACandidatePrev[i].ObjPosXY[1]<150)//旁邊車即將超過自車
		{//check whether side car is true?
			int leftX=CTACandidate[candIdx].startxi;
			int rightX=CTACandidate[candIdx].startxi+CTACandidate[candIdx].width;
			int topY=CTACandidate[candIdx].startyi;
			int bottomY=CTACandidate[candIdx].startyi+CTACandidate[candIdx].height;
			int area=(rightX-leftX)*(bottomY-topY);
			int grayLT=0, grayRT=0, grayLB=0, grayRB=0;
			UINT32 voffset;
			for(int j=topY; j<topY+20; j++)//區域內上下左右對稱姓
			{
				voffset=j*imgDimensionX;
				for(int i=leftX; i<leftX+20; i++)
				{
					grayLT+=*(img_track+voffset+i);
				}
			}
			grayLT=grayLT/400;

			for(int j=bottomY; j>bottomY-20; j--)//區域內上下左右對稱姓
			{
				voffset=j*imgDimensionX;
				for(int i=leftX; i<leftX+20; i++)
				{
					grayLB+=*(img_track+voffset+i);
				}
			}
			grayLB=grayLB/400;

			for(int j=topY; j<topY+20; j++)//區域內上下左右對稱姓
			{
				voffset=j*imgDimensionX;
				for(int i=rightX; i>rightX-20; i--)
				{
					grayRT+=*(img_track+voffset+i);
				}
			}
			grayRT=grayRT/400;

			for(int j=bottomY; j>bottomY-20; j--)//區域內上下左右對稱姓
			{
				voffset=j*imgDimensionX;
				for(int i=rightX; i>rightX-20; i--)
				{
					grayRB+=*(img_track+voffset+i);
				}
			}
			grayRB=grayRB/400;
			if( (ABS(grayLT-grayLB)<10) && 
				(ABS(grayRT-grayRB)<10) && 
				(MIN(grayLT,grayRT)*1.35>(float)MAX(grayLT,grayRT)) &&
				(MIN(grayLB,grayRB)*1.35>(float)MAX(grayLB,grayRB)) )
				CTACandidate[candIdx].retrieveEdgeTimes  = MAX(0, CTACandidatePrev[i].retrieveEdgeTimes -1) ;
		}
		//another case: 旁車退離開
		else
#endif//#if 0			
	
		if(mv_sum.minSAD>30)
			CTACandidate[candIdx].retrieveEdgeTimes  = CTACandidatePrev[i].retrieveEdgeTimes + 1 ;
			else if(moveX==0 && CTACandidatePrev[i].ObjTrackMove[0]==0 && CTACandidatePrev[i].appearCounter>TH_staticAppearCounter[1])//不追蹤靜止車輛//
			CTACandidate[candIdx].retrieveEdgeTimes  = CTACandidatePrev[i].retrieveEdgeTimes + 1 ;		
		else if(mv_sum.minSAD<20 && moveX!=0)
			CTACandidate[candIdx].retrieveEdgeTimes  = MAX(0, CTACandidatePrev[i].retrieveEdgeTimes -1) ;

			if(moveX==0)
				CTACandidate[candIdx].staticCounter = CTACandidatePrev[i].staticCounter+1;
			else
				CTACandidate[candIdx].staticCounter=0;

        CTACandidatePrev[i].isRelatedCandValid   = Valid;
        CTACandidatePrev[i].relatedCandLink      = candIdx;

		candMaxIndex=MAX(candIdx+1,candMaxIndex);
		++ret;
    }
		else
		{
			CTACandidate[candIdx].isInReviveMode  =  UpdateMove;
		}
		CTACandidate[candIdx].ObjTrackPos[0]    = CarHeadXY[0]+moveX;
		CTACandidate[candIdx].ObjTrackPos[1]    = CarHeadXY[1]+moveY;
		CTACandidate[candIdx].ObjTrackMove[0]  = moveX;
		CTACandidate[candIdx].ObjTrackMove[1]  = moveY;
		CTACandidate[candIdx].moveDir  =  moveDir;
    }
	inMaxCand=candMaxIndex;
    return ret;
}
/**
* @brief	 Filter the candidates according to previous ones
* @param[in] CTACandidate		Input Candidates at current frame
* @param[in] CandidateCount     Input the Valid Number in current CTACandidate
* @return	 the result valid number
*/
UINT16 Patches::FilterAfterPredict( CandidateRec CTACandidate[], UINT16 inMaxCand , CandidateRec CTACandidatePrev[], UINT16 inMaxCandPrev )
{
    ///1) DO Filter 
    for ( int i1 = 0 ; i1 < MAXCandidateNum ; ++i1) // CTACandidate Total Number
    {
        if( (FALSE == CTACandidate[i1].isValid) && 
            ( CTACandidate[i1].isRelatedCandValid==FALSE)) 
            continue;

        //Variables
        //CTACandidate[i1];                                     ///< the CTACandidate (T)
        //CTACandidatePrev[CTACandidate[i1].relatedPrevCand];   ///<the  CTACandidate (T-1)
        //CTACandidate[i1].isValid                              ///<the  data
        
        //@TODO: The FilterIII
    }

    //2) count the isValid
    UINT16 countValid = 0 ;
    for ( INT32 i1 = 0 ; i1 < MAXCandidateNum ; ++i1) // CTACandidate Total Number
    {
        countValid = ((TRUE == CTACandidate[i1].isValid))?(countValid+1):(countValid);
    }
    return countValid;
}

/**
* @brief	 FilterI after cluster into HeadLightL/R & calculate lampNumR/L
*/
void Patches::Filter01_Night( UCHAR *g_Binar_img, INT32 imgDimensionX, INT32 imgDimensionY, HeadLight lampL[MAX_HeadLightNum] , HeadLight lampR[MAX_HeadLightNum] , INT16 MaxLampL , INT16 MaxLampR, INT16 &lampNumL, INT16 &lampNumR,const INT32 RegionL[4], const INT32 RegionR[4] )
{
    /// small area filter 
    CONST UINT16 THD_area = 8;  ///< Pixel
    lampNumL = 0;
    lampNumR = 0;

    for ( INT16 i1 = 0 ; i1< MaxLampL ; ++i1)
    {
        if( (TRUE == lampL[i1].isValid) &&
            (THD_area > lampL[i1].area) )
        {
            lampL[i1].isValid = FALSE;
        }
        if( (TRUE == lampL[i1].isValid) )
        {
            ++lampNumL ;
        }
    }
    for ( INT16 i1 = 0 ; i1< MaxLampR ; ++i1)
    {
        if( (TRUE == lampR[i1].isValid) &&
            (THD_area > lampR[i1].area) )
        {
            lampR[i1].isValid = FALSE;
        }
        if( (TRUE == lampR[i1].isValid) )
        {
            ++lampNumR ;
        }
    }

    return;
}
/**
* @brief	 Save the Map into HarrisCornerPos structure
* @return	 the total corner number
*/
INT32 Patches::SaveCornerPos( UCHAR *harrisMap, INT32 imgDimensionX, INT32 imgDimensionY, 
                              HarrisCornerPos *harrisCorners, HarrisCornerPos2 *harrisCorners2, INT32 MAXSize )
{

#if 0
    memset(harrisCorners , 0 , sizeof(HarrisCornerPos) * MAXSizeHarrisCorner );
#endif

    UINT16 starty = RegionL[1];
    UINT16 endy   = RegionL[3];
    UINT16 Idx_harrisCorners = 0;    

    register UINT16 vert, hori;
    
    for (vert = starty ; vert < endy ; ++vert)
    {
        
    #if 1
    INT32 offsetV;
        offsetV = vert * imgDimensionX;
        for (hori = 0 ; hori < imgDimensionX ;++hori)
        {
            if( 0 == harrisMap[offsetV+hori]  ) 
                continue;

            if( ( hori>= RegionL[0]) && (hori< RegionL[2]) && ( vert >= RegionL[1]) && (vert < RegionL[3]))
            {
                harrisCorners[Idx_harrisCorners].x = hori;
                harrisCorners[Idx_harrisCorners].y = vert;
                Idx_harrisCorners = (Idx_harrisCorners < (MAXSizeHarrisCorner-1))? (Idx_harrisCorners+1) : Idx_harrisCorners ;
            }
            else if( (hori>= RegionR[0]) && (hori< RegionR[2]) && (vert>= RegionR[1]) && (vert < RegionR[3]))
            {
                harrisCorners[Idx_harrisCorners].x = hori;
                harrisCorners[Idx_harrisCorners].y = vert;
                Idx_harrisCorners = (Idx_harrisCorners < (MAXSizeHarrisCorner-1))? (Idx_harrisCorners+1) : Idx_harrisCorners ;
            }
        }
    #else
        // harris corners on left ROI
        UINT32 offset;
    
        offset = vert * imgDimensionX + RegionL[0];
        for (hori=RegionL[0]; hori<RegionL[2]; hori++)
        {
            if( 0 == harrisMap[offset++]  ) 
                continue;

            harrisCorners[Idx_harrisCorners].x = hori;
            harrisCorners[Idx_harrisCorners++].y = vert;            
            //Idx_harrisCorners++;

            if (Idx_harrisCorners == MAXSizeHarrisCorner) 
                return Idx_harrisCorners;
        }

        // harris corners on right ROI
        offset = vert * imgDimensionX + RegionR[0];
        for (hori=RegionR[0]; hori<RegionR[2]; hori++)
        {
            if( 0 == harrisMap[offset++]  ) 
                continue;
            harrisCorners[Idx_harrisCorners].x = hori;
            harrisCorners[Idx_harrisCorners++].y = vert;            
            //Idx_harrisCorners++;

            if (Idx_harrisCorners == MAXSizeHarrisCorner) 
                return Idx_harrisCorners;
        }
    #endif
    }// end of vert <= endy

    return Idx_harrisCorners; // ex. 500 means 500 corners in harrisCorners
}


Patches* Patches::getInstance()
{
    if(!instance)
        instance = new Patches;
    return instance;
}

Patches::Patches(void)
{
}


Patches::~Patches(void)
{
}



