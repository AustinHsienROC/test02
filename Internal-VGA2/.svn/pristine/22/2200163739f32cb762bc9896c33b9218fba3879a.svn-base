//******************************************************************************
// I N C L U D E   F I L E S
//******************************************************************************
#ifdef _WIN32
  #include "stdafx.h"
#else // K2 platform
  #include "GlobalTypes.h"
#endif

#include "CoordinateConversion.h"

//******************************************************************************
// I N T E R N A L   V A R I A B L E S
//******************************************************************************
//******************************************************************************
// M A C R O   D E F I N I T I O N S
//******************************************************************************
WorldModel* WorldModel::instance = NULL;

//******************************************************************************
// F U N C T I O N   B O D Y S
//******************************************************************************

/**
* @brief  世界座標(原點:最左後方 間隔單位(5cm) ) 查到 影像座標(原點 左上角 間隔單位(1pixel) ) 
* @n	  [CTA_TopView1152x120_lut.hex]
*/
void WorldModel::PosWorldToImg( INT32  PosXw, INT32  PosYw, INT32 &Posxi, INT32 &Posyi )
{
    if(PosXw <0 || PosXw>=CTA_TV_WIDTH || PosYw<0 || PosYw>=CTA_TV_HEIGHT)
    {
        Posxi = Posyi = 0;
        return;
    }
    dataBuf = CTA_LUT_TOPVIEW[ PosXw + PosYw * CTA_TV_WIDTH ];
    Posxi   = ( dataBuf & (0x0000FFFF) );
    Posyi   = ( dataBuf >> 16		   );
}

/**
* @brief  影像座標(原點 ROI_startX,Y 間隔單位(1pixel) ) 查到 世界座標(原點:最左後方 間隔單位(5cm) ) 
* @n	  [CTA_calib.hex]
*/
void WorldModel::PosImgToWorld( INT32 &PosXw, INT32 &PosYw, INT32  Posxi, INT32  Posyi)
{
    // in ROI
    if( Posxi < (CTA_Cali.ROI_start_x+CTA_Cali.ROI_width) && ( Posxi >=(CTA_Cali.ROI_start_x) )&&
        Posyi < (CTA_Cali.ROI_start_y+CTA_Cali.ROI_height)&& ( Posyi >=(CTA_Cali.ROI_start_y) ))
    {

        PosXw = ( CTA_Cali.TopView_forward_LUT[ (Posxi - CTA_Cali.ROI_start_x) + (Posyi - CTA_Cali.ROI_start_y) * (CTA_Cali.ROI_width)] & (0x0000FFFF) ); ///< 0xFFFFFFFF if OUT OF BOUNDARY
        PosYw = ( CTA_Cali.TopView_forward_LUT[ (Posxi - CTA_Cali.ROI_start_x) + (Posyi - CTA_Cali.ROI_start_y) * (CTA_Cali.ROI_width)] >> 16 );

        /* old version
        UINT16 start_x = Posxi - CTA_Cali.ROI_start_x ;
        UINT16 start_y = Posyi - CTA_Cali.ROI_start_y ;
        UINT16 width   = CTA_Cali.ROI_width ;
        UINT16 height  = CTA_Cali.ROI_height ;

        PosXw = ( CTA_Cali.TopView_forward_LUT[ start_x + start_y * width] & (0x0000FFFF) ); ///< 0xFFFFFFFF if OUT OF BOUNDARY
        PosYw = ( CTA_Cali.TopView_forward_LUT[ start_x + start_y * width] >> 16 );
        */

    }
    else // OUT OF BOUNDARY
    {
        PosXw = 0xFFFF;
        PosYw = 0xFFFF;
    }
}

/**
* @brief		Map World Position(Xw,Yw) to Image Position(xi,yi)
* @param[in]	topView_x	Input (Xw)
* @param[out]	img_x		Output(xi)
*/
void WorldModel::Coor_TopView_CameraView(INT32 LUT_width, INT32 topView_x, INT32 topView_y, INT32 &img_x, INT32 &img_y, UINT32 *LUT)
{
    UINT32 offset = *(LUT + topView_y*LUT_width + topView_x);
    img_y         = offset >> 16;
    img_x         = offset & 0xFFFF;
}

/**
* @brief	test Drive
*/
void WorldModel::testDriveCC01()
{
    INT32 tmpXw3,tmpYw3;
    INT32 tmpxi3,tmpyi3;
    int min1 = 99999;
    int max1 = 0;
    for ( int i1 = 0; i1 < 480; ++i1)
    {
        PosImgToWorld( tmpXw3 ,tmpYw3, 320,i1 );
        if(tmpYw3!= 65535)
        {
            if( tmpYw3>max1 )
                max1 = tmpYw3;
            if( tmpYw3<min1 )
                min1 = tmpYw3;
        }
    }
    PosWorldToImg( tmpXw3/CTA_TV_COMPRESS ,tmpYw3/CTA_TV_COMPRESS, tmpxi3,tmpyi3 );
    tmpXw3 = tmpXw3;    
}
WorldModel* WorldModel::getInstance()
{
    if(!instance)
        instance = new WorldModel;
    return instance;
}

WorldModel::WorldModel(void)
{
}
WorldModel::~WorldModel(void)
{
}

