//******************************************************************************
//  I N C L U D E     F I L E S
//******************************************************************************

#if defined(_WIN32)
  #include "stdafx.h"
  #include <stdlib.h>
  #include <malloc.h>
  #include <stdio.h>
  #include <math.h>
  #include <time.h>
  #include <iostream>
  #include <string>   // for strings
  #include <cassert>  // assert

  #if( ON == PC_FILE_INFO )
    #include <fstream>
  #endif
  
  #include "OpencvPlug.h"		///< Need Before "CTA_Type.h" due to VARIABLE File
  #include "Filter2D.h"
  #include "CTA_PCLog.h"
  #include "WhiteBox.h"
  #include "OSD_Plot.h"  
  #include "FilesInfo.h"
  #include "VideoHdInfo.h"
#else // for K2 platform
  #include "oTo_MemMgr.h"
  #include "Utilities.h"
  #include "MemMgr.h"
  #include "CTA_APEX.h"
  #include "ICP_Image_ROI.hpp"
  //#include "APEX_CogniVue.h"
#endif


#include "CTA_Def.h"
#include <string.h>
#include "CTAApi.h"
#include "CTA_CustomData.h"
#include "Point_Track.h"
#include "Point_Group.h"
#include "ML_NeuralNet.h"
#include "Estimation.h"
#include "WarningDecision.h"

#include "Patches.h"

#ifdef _WIN32
  #define _ENABLE_PROFILE_    (0)   // always disable K2 profile in PC simulation
#else // K2 platform
  #define _ENABLE_PROFILE_    (1)   // Enable/disable K2 profile code (to display profile info in Eclipse's console window)
#endif

#if _ENABLE_PROFILE_
    // profile init
	static uint32 tick, profile_time;	
	static int profile_idx = 0;
#endif

//******************************************************************************
// S T A T I C   V A R I A B L E S
//******************************************************************************

//-------------------Car-------------------------//
static SimpleCarSpec   carSpec;   
static CAN_Info       *carState;  

//-------------------FrameTimeStamp_FunctionStatus---------------------
static CTATimeManagement CTATime ={ 0 };
static weatherType_t CTAWeather  = Day ;
static INT32 TicIdx              =  0 ;
static TARGET_NUM CTATargetNum   ={ 0,0,0,0,0,0,0 };

//-------------------PointTrack-------------------------//
static HarrisCornerPos *harrisCorners     = NULL ;
static HarrisCornerPos *harrisCornersPrev = NULL ;

static HarrisCornerPos2 *harrisCorners2     = NULL ;
static HarrisCornerPos2 *harrisCorners2Prev = NULL ;


//-------------------Img/DataBuf-------------------------//
static INT32  g_unTotalRequestSize    = 0;       ///< All Memory Request size
static UCHAR *g_Sobel_img             = NULL;
static UCHAR *g_Sobel_imgPrev         = NULL;
static UCHAR *g_vSobel_img            = NULL;
static UCHAR *g_hSobel_img            = NULL;
//static UCHAR *g_SobelEroded_img       = NULL;
//static UCHAR *g_SobelEroded_imgPrev   = NULL;
static UCHAR *g_tag                   = NULL;

#ifdef _WIN32
static UCHAR *g_SrcY                  = NULL;   ///< src Img
static UINT16 *g_harrisValue          = NULL;
#endif

static UCHAR *g_Gaussian_img          = NULL;   ///< src Img + Gaussian
static UCHAR *g_Gaussian_imgPrev      = NULL;

static UCHAR *g_harrisMap             = NULL;
static UCHAR *g_harrisMapPrev         = NULL;

static UCHAR *g_img_FrameDiff         = NULL;

//-------[NightModeUsedOnly]--------
static UCHAR *g_bin_img               = NULL;   ///< Binary Image
static UCHAR *g_bin_PrevImg           = NULL;   ///< Binary Image previously

static UINT16 *CTAMinorBlockL_EdgeQuantity;
static UINT16 *CTAMinorBlockR_EdgeQuantity;

static UINT16 *g_VSobelQty16x16 = NULL;
static UINT16 *g_HSobelQty16x16 = NULL;


#ifndef _WIN32 // for K2 platform
  static ICP_Image gicp_Sobel;
  static ICP_Image gicp_SobelPrev;
  static ICP_Image gicp_vSobel;
  static ICP_Image gicp_hSobel;
  //static ICP_Image gicp_SobelEroded;
  //static ICP_Image gicp_SobelErodedPrev;
    //static ICP_Image gicp_SrcY;
  static ICP_Image gicp_Gaussian;
  static ICP_Image gicp_GaussianPrev;  
  static ICP_Image gicp_harrisMap;
  static ICP_Image gicp_harrisMapPrev;  
  static ICP_Image gicp_FrameDiff;
  static ICP_Image gicp_bin;
  static ICP_Image gicp_binPrev;
  static ICP_Image gicp_CTAMinorBlockL_EdgeQuantity;
  static ICP_Image gicp_CTAMinorBlockR_EdgeQuantity;
  static ICP_Image gicp_HSobelQty16x16;
  static ICP_Image gicp_VSobelQty16x16;
  
  static ICP_Image gicp_roi_Sobel;
  static ICP_Image gicp_roi_SobelPrev;
  static ICP_Image gicp_roi_vSobel;
  static ICP_Image gicp_roi_hSobel;
  //static ICP_Image gicp_roi_SobelEroded;
  //static ICP_Image gicp_roi_SobelErodedPrev;
  static ICP_Image gicp_roi_SrcY;
  static ICP_Image gicp_roi_left;
  static ICP_Image gicp_roi_right;
  
  static ICP_Image gicp_roi_Gaussian;
  static ICP_Image gicp_roi_GaussianPrev;  
  static ICP_Image gicp_roi_harrisMap;
  static ICP_Image gicp_roi_harrisMapPrev;  
  static ICP_Image gicp_roi_FrameDiff;
  static ICP_Image gicp_roi_bin;
  static ICP_Image gicp_roi_binPrev;
  
  static ICP_Image *pROI_Gaussian        = &gicp_roi_Gaussian;    
  static ICP_Image *pROI_GaussianPrev    = &gicp_roi_GaussianPrev;
  static ICP_Image *pROI_Sobel           = &gicp_roi_Sobel;
  static ICP_Image *pROI_SobelPrev       = &gicp_roi_SobelPrev;
  static ICP_Image *pROI_vSobel          = &gicp_roi_vSobel;
  static ICP_Image *pROI_hSobel          = &gicp_roi_hSobel;
  //static ICP_Image *pROI_SobelEroded     = &gicp_roi_SobelEroded;
  //static ICP_Image *pROI_SobelErodedPrev = &gicp_roi_SobelErodedPrev;    
  static ICP_Image *pROI_harrisMap       = &gicp_roi_harrisMap;
  static ICP_Image *pROI_harrisMapPrev   = &gicp_roi_harrisMapPrev;  
  static ICP_Image *pROI_FrameDiff       = &gicp_roi_FrameDiff;
  static ICP_Image *pROI_bin             = &gicp_roi_bin;
  static ICP_Image *pROI_binPrev         = &gicp_roi_binPrev;
#endif // #ifndef _WIN32 // for K2 platform

//-------------------Block/Candidates-------------------------//
static MinorBlock   CTAMinorBlockL		[ MAXCandidateNum ];
static MinorBlock   CTAMinorBlockR		[ MAXCandidateNum ];
       CandidateRec CTACandidateL	    [ MAXCandidateNum ];
       CandidateRec CTACandidateR	    [ MAXCandidateNum ];
static CandidateRec CTACandidatePrevL	[ MAXCandidateNum ];
static CandidateRec CTACandidatePrevR	[ MAXCandidateNum ];

//-------------------HeadLight-------------------------//
static HeadLight lampL     [ MAX_HeadLightNum ];
static HeadLight lampR     [ MAX_HeadLightNum ];
static HeadLight lampPrevL [ MAX_HeadLightNum ];
static HeadLight lampPrevR [ MAX_HeadLightNum ];

//******************************************************************************
// G L O B A L   V A R I A B L E S
//******************************************************************************

INT32  RegionL[4]; // = { 0 , 120 , (0+ROISegBlockNum * ROISegBlockH) , (120 + ROISegBlockNum * ROISegBlockV) };//左上xy,右下xy
INT32  RegionR[4]; // = { (SrcImg_W-1) - (ROISegBlockNum * ROISegBlockH) , 120 , SrcImg_W-1, 120 + (ROISegBlockNum * ROISegBlockV)};//左上xy,右下xy
UCHAR CTAAlarmState  =  0;
#ifdef _WIN32

	char g_FrameReport[500];//show information to debug UI< oTo_GetFrameInfo()
	int g_FrameReportIdx=0;//used index for g_FrameReport
    CHAR  VideoFilePath[240];           ///< VideoFileName

    //-------------------CTA_Log-------------------------//
    BOOL EventResultL [ MAXSizeEventResult ] = {0};
    BOOL EventResultR [ MAXSizeEventResult ] = {0};
#endif
//******************************************************************************
// I N T E R N A L   F U N C T I O N S
//****************************************************************************** 
/**
* @brief huge memory Allocation
*/
static void* CTA_calloc(UINT32 a_unDataCnt, UINT32 a_unDataSize)
{
    g_unTotalRequestSize+=(a_unDataCnt*a_unDataSize);
#ifdef _WIN32
    return calloc(a_unDataCnt, a_unDataSize) ;
#else
    return oTo_MemMgr_Allocate(a_unDataCnt*a_unDataSize);
#endif
}

/**
* @brief huge memory Release
*/
static void CTA_free(void* a_pBuf)
{
#ifdef _WIN32	
    if(NULL == a_pBuf) 
        return;
    return free( a_pBuf );
#else
    return oTo_MemMgr_Release(a_pBuf) ;
#endif
}
/**
* @brief Img process ROI assignment.
* @n     based on dynamic i_LUT
* @param[in] i_LUT	image 2 World LUT
*/
static void setImgProcROI( CTA_CaliResult_t &i_LUT )
{
    RegionL[0]   = 0;
    RegionL[2]   = RegionL[0] + ROISegBlockNum_H * ROISegBlockH ;
//    RegionR[0]   = (SrcImg_W-1) - (ROISegBlockNum_H * ROISegBlockH);
//    RegionR[2]   = (SrcImg_W-1) ;
        RegionR[0]   = (SrcImg_W) - (ROISegBlockNum_H * ROISegBlockH);
        RegionR[2]   = (SrcImg_W) ;


    INT32 endy = i_LUT.ROI_start_y + i_LUT.ROI_height - 50;

    INT32 starty ;
    for(;;) 
    {
        starty = endy - ROISegBlockNum_V * ROISegBlockV ;
        if ( starty >= i_LUT.ROI_start_y )
        {
            --starty;
            --endy;
        }
        else{ break; }
    } 
    RegionL[3] = RegionR[3] = endy;
    RegionL[1] = RegionR[1] = starty;

}

/**
*@brief		Show the basic UI information 
*@n         1.[Frame Numbers] [Boundary]
*@n         2.[CandidateInfoTemplate][TXT][TopView][ROI]
*/
#if defined(_WIN32)
static void OSD_PLOT_GeneralUI( UCHAR *dst_Y ,INT32 imgDimensionX,INT32 imgDimensionY, INT32 &in_FrameNum , SimpleCarSpec &carSpec)
{

    ///1) Show Frame Numbers
    OSD_SetColor(255, 255, 255);
    OSD_Draw_Text( (CHAR *)"Frame" , dst_Y, imgDimensionX, imgDimensionY, 0, 0, 0);
    OSD_SetColor(255, 255, 255);
    OSD_Draw_INT32( in_FrameNum , dst_Y, imgDimensionX, imgDimensionY,  10, 24, 3 ,10);

    ///2) Show Boundary(0-6m,3-15m)
    OSD_Show_Boundary( dst_Y , imgDimensionX , imgDimensionY ,carSpec );

    /* @note the Special UI

    ///4) Show CandidateInfoTemplate at Left-Bottom
    OSD_SetColor(255, 255, 0);
    OSD_Draw_Rec(dst_Y,imgDimensionX, imgDimensionY,5,400-10-5,110,470-40,1,false);
//    OSD_Draw_Text( "Stable" , dst_Y, imgDimensionX, imgDimensionY, 0, 400-25-6, 0);
    OSD_Draw_Text( "POSXooom" , dst_Y, imgDimensionX, imgDimensionY, 0, 415-25-6-4, 0);
    OSD_Draw_Text( "SPEEDookph" , dst_Y, imgDimensionX, imgDimensionY, 0, 430-25-6-4, 0);
    OSD_Draw_Text( "TTCoooosec" , dst_Y, imgDimensionX, imgDimensionY, 0, 445-25-6-4, 0);
    */

    ///5) Plot Motion Estimation ROI
    OSD_SetColor(155, 155, 155);
    OSD_Draw_Rec(dst_Y, imgDimensionX, imgDimensionY, RegionL[0], RegionL[1], RegionL[2], RegionL[3],3,FALSE ,1);
    OSD_Draw_Rec(dst_Y, imgDimensionX, imgDimensionY, RegionR[0], RegionR[1], RegionR[2], RegionR[3],3,FALSE, 1);

    ///6) EXPORT TXT
#   if ( ON == DBG_TXT)
    //FILE *fptr;
    //errno_t err=fopen_s(&fptr,"c:\\test\\CTA_output.txt","a");
    //fprintf(fptr,"idx(FrameNum)=%d, TH(Harris)=%d, PointNum=%d \n", FrameNum, TH, pointNumber);
    //fclose(fptr);
#   endif

    //5) OpenCV show TopView
#   if (( ON == OPENCV_EN ) && (ON == SHOW_BV)) 
    UCHAR BVImage[CTA_TV_WIDTH*CTA_TV_HEIGHT];
    INT32 xi,yi;

    for ( int vert = 0 ; vert < CTA_TV_HEIGHT;++vert)
        for ( int hori=0 ; hori < CTA_TV_WIDTH;++hori)
        {
            WModel->PosWorldToImg( hori, vert , xi, yi );
            BVImage[ hori + vert*CTA_TV_WIDTH ] = dst_Y[ xi + imgDimensionX * yi ];
        }

    OPENCV->ShowImg(BVImage,CTA_TV_WIDTH,CTA_TV_HEIGHT);
#   endif
}
#endif // #if defined(_WIN32)

/** This function is called only at end of each frame
*@brief		save the Image & struct data for next frame estimation purpose.
*@param[in] g_Gaussian_img	Gaussian image
*@param[in] g_Sobel_img		Gradient sobel image
*@param[in] harrisCorners	Harris corners structure
*@param[in] CTACandidateL	Objects Info.
*@param[in] FrameNum		Frame Number
*/
void Update_Data_Before_Next_Frame( CandidateRec *CTACandidateL, CandidateRec *CTACandidatePrevL, CandidateRec *CTACandidateR, CandidateRec *CTACandidatePrevR, TARGET_NUM &inCTATarget, INT32 &inFrameNum ,INT32 imgDimensionX,INT32 imgDimensionY )
{

#pragma region//=========UpdateData=========

    for( INT32 i=0; i<inCTATarget._L_MaxCandNum; i++)
        if(CTACandidateL[i].isValid)
            CTACandidateL[i].appearCounter++;
    for( INT32 i=0; i<inCTATarget._R_MaxCandNum; i++)
        if(CTACandidateR[i].isValid)
            CTACandidateR[i].appearCounter++;

    inFrameNum++;

#pragma endregion

#pragma region//=========MoveData=========

    /// Prev [Image/ g_Sobel_imgPrev ] Frame Saving
    UCHAR *p_tmp;
    
    p_tmp              = g_Gaussian_imgPrev;
    g_Gaussian_imgPrev = g_Gaussian_img;
    g_Gaussian_img     = p_tmp;
#if 0
    memset(g_Gaussian_img , 0 , imgDimensionX*imgDimensionY*sizeof(UCHAR) );
#endif

    p_tmp              = g_Sobel_imgPrev;
    g_Sobel_imgPrev    = g_Sobel_img;
    g_Sobel_img        = p_tmp;
#if 0    
    memset(g_Sobel_img , 0 , imgDimensionX*imgDimensionY*sizeof(UCHAR) );
#endif

    //p_tmp                 = g_SobelEroded_imgPrev;
    //g_SobelEroded_imgPrev = g_SobelEroded_img;
    //g_SobelEroded_img     = p_tmp;
    //memset(g_SobelEroded_img , 0 , imgDimensionX*imgDimensionY*sizeof(UCHAR) );

    /// Prev  Harris Corners Frame
    HarrisCornerPos *p_tmp2;
    p_tmp2            = harrisCornersPrev;
    harrisCornersPrev = harrisCorners;
    harrisCorners     = p_tmp2;
#if 0    
    memset(harrisCorners , 0 , sizeof(HarrisCornerPos)*MAXSizeHarrisCorner );
#endif

    HarrisCornerPos2 *p_tmp3;
    p_tmp3            = harrisCorners2Prev;
    harrisCorners2Prev = harrisCorners2;
    harrisCorners2     = p_tmp3;
#if 1 // cause different from Rev605_Mark if define 0
    memset(harrisCorners2 , 0 , sizeof(HarrisCornerPos2)*MAXSizeHarrisCorner );
#endif

    p_tmp           = g_harrisMapPrev;
    g_harrisMapPrev = g_harrisMap;
    g_harrisMap     = p_tmp;
#if 0
    memset(g_harrisMap , 0 , imgDimensionX*imgDimensionY*sizeof(UCHAR) );
#endif

#ifndef _WIN32  // for K2 platform
    ICP_Image *picp_tmp;

    picp_tmp           = pROI_GaussianPrev;
    pROI_GaussianPrev = pROI_Gaussian;
    pROI_Gaussian     = picp_tmp;
    
    picp_tmp           = pROI_SobelPrev;
    pROI_SobelPrev    = pROI_Sobel;
    pROI_Sobel        = picp_tmp;

    picp_tmp            = pROI_harrisMapPrev;
    pROI_harrisMapPrev = pROI_harrisMap;
    pROI_harrisMap     = picp_tmp;
#endif // END #ifndef _WIN32  // for K2 platform

#if 1
    CTATargetNum.FeaturePtNumPrev = CTATargetNum.FeaturePtNum;
    // reset previous CTACandidate
    memset(&CTACandidatePrevL[0] , 0 , inCTATarget._L_MaxCandNumPrev * sizeof(CandidateRec) );
    memset(&CTACandidatePrevR[0] , 0 , inCTATarget._R_MaxCandNumPrev * sizeof(CandidateRec) );
        
    INT32 counter,i;
    for( counter= i=0; i<inCTATarget._L_MaxCandNum; i++) {
        if(CTACandidateL[i].isValid) {
            memcpy( &CTACandidatePrevL[counter] , &CTACandidateL[i] , sizeof(CandidateRec) );
            CTACandidatePrevL[counter].relatedCandLink    = 0 ;
            CTACandidatePrevL[counter++].isRelatedCandValid = Invalid ;
        }
    }
    inCTATarget._L_MaxCandNumPrev=counter;


    for( counter= i=0; i<inCTATarget._R_MaxCandNum; i++) {
        if(CTACandidateR[i].isValid) {
            memcpy( &CTACandidatePrevR[counter] , &CTACandidateR[i] , sizeof(CandidateRec) );
            CTACandidatePrevR[counter].relatedCandLink    = 0 ;
            CTACandidatePrevR[counter++].isRelatedCandValid = Invalid ;
        }
    }
    inCTATarget._R_MaxCandNumPrev=counter;

    ///0) Clear Candidates
    memset(&CTACandidateL[0] , 0 , inCTATarget._L_MaxCandNum*sizeof(CTACandidatePrevL[0]) );
    memset(&CTACandidateR[0] , 0 , inCTATarget._R_MaxCandNum*sizeof(CTACandidatePrevR[0]) );
    inCTATarget._L_MaxCandNum=0;
    inCTATarget._R_MaxCandNum=0;
/*
    for ( i = 0 ; i < inCTATarget._L_MaxCandNumPrev ; ++i) //MAXCandidateNum
    {
        CTACandidatePrevL[i].relatedCandLink    = 0 ;
        CTACandidatePrevL[i].isRelatedCandValid = Invalid ;
    }
    for ( i = 0 ; i < inCTATarget._R_MaxCandNumPrev ; ++i) //MAXCandidateNum
    {
        CTACandidatePrevR[i].relatedCandLink    = 0 ;
        CTACandidatePrevR[i].isRelatedCandValid = Invalid ;
    }
  */  
#else
    // Previous CTACandidate
    memcpy( &CTACandidatePrevL[0] , &CTACandidateL[0] , MAXCandidateNum*sizeof(CandidateRec) );
    memcpy( &CTACandidatePrevR[0] , &CTACandidateR[0] , MAXCandidateNum*sizeof(CandidateRec) );

    // Target Number
    inCTATarget._L_MaxCandNumPrev = inCTATarget._L_MaxCandNum;
    inCTATarget._R_MaxCandNumPrev = inCTATarget._R_MaxCandNum;
    inCTATarget._L_MaxCandNum=0;
    inCTATarget._R_MaxCandNum=0;
#endif

#pragma endregion//=========MoveData end=========
#pragma region//=========重設資料start=========

#pragma endregion//=========重設資料end=========

/* old version
#pragma region//=========搬動資料start=========

    /// Prev [Image/ g_Sobel_imgPrev ] Frame Saving
    memcpy( Gaussian_Previmg , Gaussian_img ,imgDimensionX*imgDimensionY*sizeof(Gaussian_img[0]));
    memcpy( Sobel_imgPrev,Sobel_img, imgDimensionX*imgDimensionY*sizeof(Sobel_img[0]));
    memcpy( SobelEroded_imgPrev,SobelEroded_img, imgDimensionX*imgDimensionY*sizeof(SobelEroded_img[0]));

    /// Prev  Harris Corners Frame
    memset(harrisCornersPrev , 0 , sizeof(HarrisCornerPos)*MAXSizeHarrisCorner );
    memcpy(harrisCornersPrev , harrisCorners , sizeof(HarrisCornerPos)*MAXSizeHarrisCorner );
    memset(harrisCorners     , 0 , sizeof(HarrisCornerPos)*MAXSizeHarrisCorner );
    memcpy(harrisMapPrev,harrisMap,imgDimensionX*imgDimensionY*sizeof(harrisMap[0]));

#if 1
    // reset previous CTACandidate
    memset(&CTACandidatePrevL[0] , 0 , MAXCandidateNum * sizeof(CandidateRec) );
    memset(&CTACandidatePrevR[0] , 0 , MAXCandidateNum * sizeof(CandidateRec) );
    INT32 counter,i;
    for( counter= i=0; i<inCTATarget._L_MaxCandNum; i++)
        if(CTACandidateL[i].isValid)
            memcpy( &CTACandidatePrevL[counter++] , &CTACandidateL[i] , sizeof(CandidateRec) );
    inCTATarget._L_MaxCandNumPrev=counter;
    inCTATarget._L_MaxCandNum=0;

    for( counter= i=0; i<inCTATarget._R_MaxCandNum; i++)
        if(CTACandidateR[i].isValid)
            memcpy( &CTACandidatePrevR[counter++] , &CTACandidateR[i] , sizeof(CandidateRec) );
    inCTATarget._R_MaxCandNumPrev=counter;
    inCTATarget._R_MaxCandNum=0;

#else
    // Previous CTACandidate
    memcpy( &CTACandidatePrevL[0] , &CTACandidateL[0] , MAXCandidateNum*sizeof(CandidateRec) );
    memcpy( &CTACandidatePrevR[0] , &CTACandidateR[0] , MAXCandidateNum*sizeof(CandidateRec) );

    // Target Number
    inCTATarget._L_MaxCandNumPrev = inCTATarget._L_MaxCandNum;
    inCTATarget._R_MaxCandNumPrev = inCTATarget._R_MaxCandNum;
    inCTATarget._L_MaxCandNum=0;
    inCTATarget._R_MaxCandNum=0;
#endif

#pragma endregion
#pragma region=========Reset_Data=========

    ///0) Clear Candidates
    memset(&CTACandidateL[0] , 0 , MAXCandidateNum*sizeof(CTACandidatePrevL[0]) );
    memset(&CTACandidateR[0] , 0 , MAXCandidateNum*sizeof(CTACandidatePrevR[0]) );

    for ( i = 0 ; i < inCTATarget._L_MaxCandNumPrev ; ++i) //MAXCandidateNum
    {
        CTACandidatePrevL[i].relatedCandLink    = 0 ;
        CTACandidatePrevL[i].isRelatedCandValid = Invalid ;
    }
    for ( i = 0 ; i < inCTATarget._R_MaxCandNumPrev ; ++i) //MAXCandidateNum
    {
        CTACandidatePrevR[i].relatedCandLink    = 0 ;
        CTACandidatePrevR[i].isRelatedCandValid = Invalid ;
    }
#pragma endregion
*/
}
/**
*@brief	    [NightMode)] save the Image & struct data for next frame estimation purpose.
*/
static void Update_Data_Before_Next_Frame_Night( HeadLight *lampL, HeadLight *lampR, HeadLight *lampPrevL,HeadLight *lampPrevR, TARGET_NUM &CTATargetNum,INT32 &inFrameNum, INT32 imgDimensionX , INT32 imgDimensionY )
{
    ++inFrameNum;

    /// Prev [Image] Frame Saving
    UCHAR *tmp1;
    tmp1               = g_Gaussian_imgPrev;
    g_Gaussian_imgPrev = g_Gaussian_img;
    g_Gaussian_img     = tmp1;

    tmp1               = g_bin_PrevImg;
    g_bin_PrevImg      = g_bin_img;
    g_bin_img          = tmp1;

    //INT32 size_image = imgDimensionX*imgDimensionY*sizeof( UCHAR );
    //memcpy( Gaussian_imgPrev , Gaussian_img , size_image );
    //memcpy( bin_Previmg      , bin_img      , size_image );

    /// HeadLight Restore and Reset
    INT32 size_HeadLight = sizeof(HeadLight) * MAX_HeadLightNum;
    
    HeadLight *tmp2;
    tmp2      = lampPrevL;
    lampL     = lampPrevL;
    lampPrevL = tmp2;
    tmp2      = lampPrevR;
    lampR     = lampPrevR;
    lampPrevR = tmp2;
    // old version
    //memcpy(lampPrevL , lampL , size_HeadLight );
    //memcpy(lampPrevR , lampR , size_HeadLight );

    memset(lampL , 0  , size_HeadLight );
    memset(lampR , 0  , size_HeadLight );

    /// Target Number
    CTATargetNum._L_MaxCandNumPrev = CTATargetNum._L_MaxCandNum;
    CTATargetNum._R_MaxCandNumPrev = CTATargetNum._R_MaxCandNum;
}
/**
*@brief					Return the DayNightMode by average means in block
*@param[in] dst_Y		YCbCr ImgData
*@param[in] isDay		the current weatherType_t mode
*@return                decision the weatherType_t mode
*/
static weatherType_t GetWheatherType(UCHAR *dst_Y, INT32 imgDimensionX,INT32 imgDimensionY , INT32 inFrameNum , weatherType_t isDay)
{
    assert("Advance: Using ML for regions color histogram");

    const  INT32 THD_DetectInterval = 5*1;  ///< 5 Sec
    const  INT32 THD_DaytoNight     = 40;   ///< graylevel = 30
    const  INT32 THD_NighttoDay     = 55;   ///< graylevel = 30

    const  FLOAT SmoothRatio     = 0.1;   ///< (SmoothRatio)*MeanNow + ( 1- SmoothRatio)MeanPrev

    /// block position
    const INT16 CenterWidth  = 74; ///< SrcImg_W/10; 
    const INT16 CenterHeight = 52; ///<SrcImg_W/10; 
    const INT16 startRow     = (imgDimensionY>>1) + 150;
    const INT16 startCol     = (imgDimensionX>>1) -(CenterWidth>>1); 

    static INT32 counter1    = 0;
    static FLOAT meanBlock = 70;    ///< Start with Day Mode
    
    weatherType_t ret = isDay;
    
    if( ABS((counter1-inFrameNum)) < THD_DetectInterval ){ return ret; }
    
    {
        weatherType_t retWeather = Day;
        UCHAR imgCenter[CenterWidth * CenterHeight] = {0};
        counter1 = inFrameNum;

        /// 1) image copy to imgCenter
        for ( INT32 vert = 0; vert < CenterHeight; ++vert)
        {
            for (INT32 hori = 0; hori < CenterWidth; ++hori)
            {
                imgCenter[hori + vert*CenterWidth] = dst_Y[(  startCol + hori + imgDimensionX*(startRow + vert) )*2];
            }
        }

        ///2) Get Mean
        FLOAT mean = 0;
        INT32 imgCenterSize = (CenterWidth*CenterHeight);
        for( INT32 i1 = 0 ; i1 < imgCenterSize ; ++i1)
            mean += imgCenter[i1];
        mean /= (FLOAT)imgCenterSize;

        ///3) Smooth Ratio
        meanBlock = SmoothRatio*(mean) + (1-SmoothRatio)*meanBlock;

        ///3) Decision Making
        if( 0 == (CTATargetNum._L_CandNum + CTATargetNum._R_CandNum) )
        {
            if( (Day == isDay)&&( THD_DaytoNight >meanBlock ) )
            {
                ret = Night;
            }
            else if ( (Night == isDay) &&( THD_NighttoDay <meanBlock ) )
            {
                ret = Day;
            }
            return ret;
        }
        else /// Candidates Tracking
        {
            return ret;
        }
        assert(!"Cannot goto here");
    }

}
/** [DAYMode]CTA Process */
static void CTA_ProcessDay  (UCHAR *dst_Y);
/** [NIGHTMode]CTA Process */
static void CTA_ProcessNight(UCHAR *dst_Y);

//******************************************************************************
// F U N C T I O N S
//******************************************************************************
    
/**
* @brief Global Variable CTA Buffer Allocate before start.
* @n     It will be called before other functions are called
* @n     You shall allocate your memory and initial your code in the function
*/
void CTA_WorkBuf_Allocate(void) 
{
    INT32 img_width      = SrcImg_W ;
    INT32 img_height     = SrcImg_H ;
    g_unTotalRequestSize = 0; ///< Reset memory counter

    carState			   = (CAN_Info *)CTA_calloc(sizeof(CAN_Info), 1);
#ifdef _WIN32
    g_harrisValue          = (UINT16 *)CTA_calloc(sizeof(UINT16), img_width*img_height);
    g_SrcY                 = (UCHAR *) CTA_calloc(sizeof(UCHAR), img_width*img_height); // g_SrcY -> g_Gaussian_img
#endif
    g_harrisMap            = (UCHAR *)CTA_calloc(sizeof(UCHAR), img_width*img_height);
    g_harrisMapPrev        = (UCHAR *)CTA_calloc(sizeof(UCHAR), img_width*img_height);
    g_Sobel_img            = (UCHAR *) CTA_calloc(sizeof(UCHAR), img_width*img_height);
    g_vSobel_img           = (UCHAR *) CTA_calloc(sizeof(UCHAR), img_width*img_height); //template image for left-right discrimation
    g_hSobel_img           = (UCHAR *) CTA_calloc(sizeof(UCHAR), img_width*img_height);
 //   g_SobelEroded_img      = (UCHAR *) CTA_calloc(sizeof(UCHAR), img_width*img_height); ///< temp used
 //   g_SobelEroded_imgPrev  = (UCHAR *) CTA_calloc(sizeof(UCHAR), img_width*img_height); ///< temp used

    g_tag                  = (UCHAR *) CTA_calloc(sizeof(UCHAR), img_width*120);
    g_Gaussian_img         = (UCHAR *) CTA_calloc(sizeof(UCHAR), img_width*img_height);
    g_Gaussian_imgPrev     = (UCHAR *) CTA_calloc(sizeof(UCHAR), img_width*img_height);

    harrisCorners          = (HarrisCornerPos *) CTA_calloc(sizeof(HarrisCornerPos),MAXSizeHarrisCorner);
    harrisCornersPrev      = (HarrisCornerPos *) CTA_calloc(sizeof(HarrisCornerPos),MAXSizeHarrisCorner);
    harrisCorners2         = (HarrisCornerPos2 *) CTA_calloc(sizeof(HarrisCornerPos2),MAXSizeHarrisCorner);
    harrisCorners2Prev     = (HarrisCornerPos2 *) CTA_calloc(sizeof(HarrisCornerPos2),MAXSizeHarrisCorner);        

    for( int row = 0 ; row < 120; row++ )
    {
        for(int column=0; column<img_width/2; column++)
        {
            g_tag[row*img_width+column]             = 1;
            g_tag[row*img_width+column+img_width/2] = 0;
        }
    }

    g_Sobel_imgPrev = (UCHAR *) CTA_calloc(sizeof(UCHAR), img_width*img_height);
    g_img_FrameDiff = (UCHAR *) CTA_calloc(sizeof(UCHAR), img_width*img_height);
    g_bin_img       = (UCHAR *) CTA_calloc(sizeof(UCHAR), img_width*img_height);
    g_bin_PrevImg   = (UCHAR *) CTA_calloc(sizeof(UCHAR), img_width*img_height);
    
    CTAMinorBlockL_EdgeQuantity = (UINT16 *) CTA_calloc(sizeof(UINT16), MAXCandidateNum);
    CTAMinorBlockR_EdgeQuantity = (UINT16 *) CTA_calloc(sizeof(UINT16), MAXCandidateNum);
    
    g_HSobelQty16x16 = (UINT16 *) CTA_calloc(sizeof(UINT16), ROISegBlockNum_H*2*ROISegBlockNum_V);
    g_VSobelQty16x16 = (UINT16 *) CTA_calloc(sizeof(UINT16), ROISegBlockNum_H*2*ROISegBlockNum_V);    
    
#ifndef _WIN32 // for K2 platform
    ICP_Image_Descriptor dpr;
    LIB_RESULT lib_ret;
        
    dpr.Configure(img_width, img_height, ICP_COLOR_GRAYSCALE);
    lib_ret = gicp_Gaussian.Create(&dpr, g_Gaussian_img);    
    lib_ret = gicp_GaussianPrev.Create(&dpr, g_Gaussian_imgPrev);   
    lib_ret = gicp_Sobel.Create(&dpr, g_Sobel_img);    
    lib_ret = gicp_SobelPrev.Create(&dpr, g_Sobel_imgPrev);
    lib_ret = gicp_vSobel.Create(&dpr, g_vSobel_img);
    lib_ret = gicp_hSobel.Create(&dpr, g_hSobel_img);    
    //lib_ret = gicp_SobelEroded.Create(&dpr, g_SobelEroded_img);
    //lib_ret = gicp_SobelErodedPrev.Create(&dpr, g_SobelEroded_imgPrev);    
    lib_ret = gicp_harrisMap.Create(&dpr, g_harrisMap);
    lib_ret = gicp_harrisMapPrev.Create(&dpr, g_harrisMapPrev);
    lib_ret = gicp_FrameDiff.Create(&dpr, g_img_FrameDiff);
    lib_ret = gicp_bin.Create(&dpr, g_bin_img);
    lib_ret = gicp_binPrev.Create(&dpr, g_bin_PrevImg);
    
    dpr.Configure(ROISegBlockNum_H, ROISegBlockNum_V, ICP_COLOR_INT16U(1));
    lib_ret = gicp_CTAMinorBlockL_EdgeQuantity.Create(&dpr, CTAMinorBlockL_EdgeQuantity);
    lib_ret = gicp_CTAMinorBlockR_EdgeQuantity.Create(&dpr, CTAMinorBlockR_EdgeQuantity);

    dpr.Configure(ROISegBlockNum_H*2, ROISegBlockNum_V, ICP_COLOR_INT16U(1));
    lib_ret = gicp_HSobelQty16x16.Create(&dpr, g_HSobelQty16x16);
    lib_ret = gicp_VSobelQty16x16.Create(&dpr, g_VSobelQty16x16);
    
    ICP_Image_ROI roi; 
    roi.xOffset = 0;
    roi.yOffset = RegionL[1];
    roi.width = imgDimensionX;
    roi.height = RegionL[3] - RegionL[1];
    
    lib_ret = gicp_roi_Gaussian.Create(&gicp_Gaussian, &roi, 0);
    lib_ret = gicp_roi_GaussianPrev.Create(&gicp_GaussianPrev, &roi, 0);    
    lib_ret = gicp_roi_Sobel.Create(&gicp_Sobel, &roi, 0);
    lib_ret = gicp_roi_SobelPrev.Create(&gicp_SobelPrev, &roi, 0);
    lib_ret = gicp_roi_vSobel.Create(&gicp_vSobel, &roi, 0);
    lib_ret = gicp_roi_hSobel.Create(&gicp_hSobel, &roi, 0);
    lib_ret = gicp_roi_harrisMap.Create(&gicp_harrisMap, &roi, 0);
    lib_ret = gicp_roi_harrisMapPrev.Create(&gicp_harrisMapPrev, &roi, 0);
    lib_ret = gicp_roi_FrameDiff.Create(&gicp_FrameDiff, &roi, 0);
    lib_ret = gicp_roi_bin.Create(&gicp_bin, &roi, 0);
    lib_ret = gicp_roi_binPrev.Create(&gicp_binPrev, &roi, 0);
    
    pROI_Sobel           = &gicp_roi_Sobel;
    pROI_SobelPrev       = &gicp_roi_SobelPrev;
    pROI_vSobel          = &gicp_roi_vSobel;
    pROI_hSobel          = &gicp_roi_hSobel;
    //pROI_SobelEroded     = &gicp_roi_SobelEroded;
    //pROI_SobelErodedPrev = &gicp_roi_SobelErodedPrev;
    pROI_Gaussian        = &gicp_roi_Gaussian;
    pROI_GaussianPrev    = &gicp_roi_GaussianPrev;
    pROI_harrisMap       = &gicp_roi_harrisMap;
    pROI_harrisMapPrev   = &gicp_roi_harrisMapPrev;  
    pROI_FrameDiff       = &gicp_roi_FrameDiff;
    pROI_bin             = &gicp_roi_bin;
    pROI_binPrev         = &gicp_roi_binPrev;       
#endif // #ifndef _WIN32 // for K2 platform    
}
/**
* @brief	 Update the Calibration LUT oTo_SetData will be called after called CTA_WorkBuf_Allocate()
* @param[in] a_unParameterID	Type of LUT(xiToXw or XwtoXi)
* @param[in] a_pData			Input Data
* @param[in] a_pData			Input DataSize
*/
bool CTA_UpdateLUT(UINT32 a_unParameterID, UCHAR * a_pData, UINT32 a_unDataSize)       // (oTo_UpdateParameter) LUT, Custom Car data
{
    /*-----------------+-------------------------------------------------------+------------
      a_unParameterID  |   DESCRIPTION  					
     ------------------+-------------------------------------------------------+------------
      0                | [ Image   to TopView ]  LUT   	
     ------------------+-------------+-----------------------------------------+------------
      1                | [ TOPView to Image   ]  LUT 
     ------------------+-------------------------------------------------------+------------
    */
#ifdef _WIN32    
    if ( 0 == a_unParameterID )
    {
        UINT32 deb01 = sizeof(WModel->CTA_Cali);//923532
        if(a_unDataSize != sizeof(CTA_CaliResult_t)){ assert(!"dead in oTo_UpdateParameter"); return false; }
        else
        {
            memcpy( &WModel->CTA_Cali , a_pData, sizeof(CTA_CaliResult_t) ); ///< img to TOPView LUT
            setImgProcROI( WModel->CTA_Cali );
        }
    }
    else if(1 == a_unParameterID)
    {
        UINT32 deb01 = sizeof(WModel->CTA_LUT_TOPVIEW); // 552960 = 138240*4(UINT32) = 576*2 * 120 *4
        if(a_unDataSize != sizeof(WModel->CTA_LUT_TOPVIEW)){ assert(!"dead in oTo_UpdateParameter"); return false; }
        else
        {
            memcpy( WModel->CTA_LUT_TOPVIEW ,a_pData, sizeof( WModel->CTA_LUT_TOPVIEW ) );///< TOPView to img LUT
        }
    }
#endif

#if defined(SYNC_ACROSS_PlAT)
#   ifdef DATA_PATTERN_FOUNTAINHEAD 
    if ( 0 == a_unParameterID ) {
        LoadLUT_Img2World(GetFullPathFileName(C_MOD_DUMP_INPUT_PATH, "00_LUT_Img2World.DAT"), &WModel->CTA_Cali);
        setImgProcROI( WModel->CTA_Cali );
    }
    if ( 1 == a_unParameterID )
        LoadLUT_World2Img(GetFullPathFileName(C_MOD_DUMP_INPUT_PATH, "00_LUT_World2Img.DAT"), WModel->CTA_LUT_TOPVIEW);
#   else
    if ( 0 == a_unParameterID ) // [ Image to TopView ]  LUT   	
        DumpLUT_Img2World(GetFullPathFileName(C_MOD_DUMP_INPUT_PATH, "00_LUT_Img2World.DAT"), &WModel->CTA_Cali);
    if ( 1 == a_unParameterID )
        DumpLUT_World2Img(GetFullPathFileName(C_MOD_DUMP_INPUT_PATH, "00_LUT_World2Img.DAT"), WModel->CTA_LUT_TOPVIEW);
#   endif
#endif

    return true;
}
/**
* @brief	 Update the Basic Car Info.
*/
bool CTA_UpdateCarInfo(UCHAR * a_pData, UINT32 a_unDataSize)  // (oTo_UpdateParameter) LUT, Custom Car data
{
#ifdef _WIN32
    if (a_unDataSize != sizeof (CustomData1_st) ){ assert(!"dead in oTo_UpdateParameter"); return false;}

    CustomData1_st *pCustomData = (CustomData1_st*) a_pData;

    carSpec.CarWidth_cm             = (UINT32)pCustomData->usCarWidth;             ///< about Benson Car: 171cm
    carSpec.RearTireToBumper_cm     = (UINT32)pCustomData->usRearTireToBumper_cm;  ///< about 100cm
    carSpec.SteerOverFrontTireRatio = (DOUBLE)pCustomData->unSTEER_OVER_FRONT_TIRE_Numerator / (DOUBLE)pCustomData->unSTEER_OVER_FRONT_TIRE_Denominator; ///< about 15.6
    carSpec.WheelBase_cm            = (UINT32)pCustomData->usWheelBase_cm;         ///< about 260cm
#endif


#ifdef SYNC_ACROSS_PlAT 
#   ifdef DATA_PATTERN_FOUNTAINHEAD
    LoadCarInfo(GetFullPathFileName(C_MOD_DUMP_INPUT_PATH, "00_carSpec.DAT")
                ,&carSpec);
#   else
    DumpCarInfo(GetFullPathFileName(C_MOD_DUMP_INPUT_PATH, "00_carSpec.DAT")
                ,&carSpec);
#   endif
#endif
    return true;

}

void CTA_UpdateCarState( UCHAR *FrameHd )
{
#ifdef _WIN32
    ///1) [TimeStamp / FrameHeaderExtract] Info Extract
    static DOUBLE lastTime, currentTime; ///< Time(ms) at the Video 
    DOUBLE timeInterval;				 ///< Frame Interval when Recorder[sec] (ex. 0.032)
    if (NULL != FrameHd)
    {
        currentTime           = (DOUBLE)GetVideoFrameHdInfo_TimeStamp(FrameHd);
        carState->time_stamp   = (UINT32)GetVideoFrameHdInfo_TimeStamp(FrameHd);
        carState->carSpeed     = (FLOAT) GetVideoFrameHdInfo_CarSpeed_10Times(FrameHd)/(FLOAT)10;
        carState->steerAngle   = (FLOAT) GetVideoFrameHdInfo_CarAngle_10Times(FrameHd)/(FLOAT)10;
        carState->frameCounter = (INT32) GetVideoFrameHdInfo_FrameCount(FrameHd);
        if( CTATime.FrameNum > 0 )
        {
            timeInterval           = (currentTime>lastTime)?( ( currentTime - lastTime )*0.001 ):(( currentTime+(DOUBLE)4294967295 - lastTime  )*0.001 );	//Unit:(sec)
            carState->timeInterval = (currentTime>lastTime)?( ( currentTime - lastTime ) )      :(( currentTime+(DOUBLE)4294967295 - lastTime  )       );	//Unit:(ms)
            CTATime.fps            = PRECISION_3( ((FLOAT)1000/(FLOAT)carState->timeInterval) );
        }
        lastTime = currentTime;
    }
#endif
}

#ifdef _WIN32
void CTA_Process(UCHAR *dst_Y, UCHAR *src_Y, UCHAR *FrameHd) ///< PC Sim
{
#else // K2 platform
void CTA_Process(ICP_Image *picp_src_Y)
{    
	UCHAR *dst_Y = NULL;			// dummy pointer in K2
	UCHAR *g_SrcY = NULL;
	UCHAR *FrameHd = NULL;   		// dummy pointer in K2
    UINT16 *g_harrisValue = NULL;	// dummy pointer in K2
	
	g_SrcY = (UCHAR *)picp_src_Y->ReturnPlanePtrRW(0);
#endif
    CONST UINT16 TH        = ( 14000 );   ///< Harris Thd of R
    CONST UCHAR e_value    = 1;
    CONST UCHAR ThdBinary  = 100;
    CONST UCHAR THD_Binary = 220;         ///< image binarilization
    const UCHAR THD_SobelEdge = 10;     // threshold for vSobelQty16x16 and hSobelQty16x16s
    
#   ifdef _WIN32
    TicIdx = 0;
    QueryPerformanceFrequency(&CTATime.cpuFreq);
    QueryPerformanceCounter ( &CTATime.TicCounter[TicIdx++] );
#   pragma region    ============PLOT_GeneralUI[ARM]============
    ///1) Copy src_Y[YCbCr] to dst_Y[YCbCr].
    Display_OriginalView( dst_Y, imgDimensionX, imgDimensionY, src_Y, imgDimensionX, imgDimensionY );

    ///2) Extract Y channel from src_Y(YCbCr) to g_SrcY(Y)
    Extract_Y_From_YCbYCr( g_SrcY, src_Y, imgDimensionX, imgDimensionY );

    ///3)Additional UI for debug[show TopView/Boundary(3-15m)/Frame Numbers/ Export TXT]
    OSD_PLOT_GeneralUI( dst_Y ,imgDimensionX , imgDimensionY , CTATime.FrameNum, carSpec );
#   pragma endregion ╮(￣▽ ￣)╭

    ///FrameHeaderExtract Info Extract
    CTA_UpdateCarState(FrameHd);

#   endif
    /// ==VERIFY== Plot carSpeed/steerAngle
    verify_SrcImg_Header(dst_Y, imgDimensionX, imgDimensionY,
                         g_SrcY, imgDimensionX, imgDimensionY, FrameHd , carState, CTATime, CTATargetNum,g_Gaussian_imgPrev,g_Sobel_imgPrev,g_harrisMapPrev,harrisCornersPrev,CTACandidatePrevL,CTACandidatePrevR,
                         CTATargetNum.FeaturePtNumPrev);
#   ifdef _WIN32
    QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] ); //[1]
#   endif
#   ifdef _WIN32
    #   pragma region ============Image_PreProcess_&_GetFeaturePoints============
    /// Gaussian Image[ g_Gaussian_img ]
    ImgFilter->Apex_Process_0_Gaussian( g_Gaussian_img, g_SrcY, imgDimensionX, imgDimensionY );

    /// Sobel image [ g_Sobel_img , g_vSobel_img , g_hSobel_img]
    ImgFilter->Apex_Process_1_0_SobelErosion(g_Sobel_img, g_vSobel_img, g_hSobel_img, g_Gaussian_img, imgDimensionX, imgDimensionY);

    // Frame Difference [ g_img_FrameDiff ]
    ImgFilter->FLT_ABSDiff( g_img_FrameDiff,  g_Gaussian_img , g_Gaussian_imgPrev, 6 ,imgDimensionX, imgDimensionY);
    //ImgFilter->FLT_ABSDiff( g_img_FrameDiff,  g_Sobel_img , g_Sobel_imgPrev, 10 ,imgDimensionX, imgDimensionY);

    ImgFilter->CalculateHarrisValue(g_harrisValue, g_hSobel_img, g_vSobel_img, imgDimensionX, imgDimensionY);
    //ImgFilter->SupressNonMaxCornerRemoveSimilar(g_harrisMap, g_harrisValue, g_Gaussian_img, imgDimensionX, imgDimensionY, TH, e_value);
    ImgFilter->SupressNonMaxRemoveStill(g_harrisMap, g_harrisValue, g_Gaussian_img, g_img_FrameDiff, imgDimensionX, imgDimensionY, TH, e_value);

    /// Frame Difference [ g_img_FrameDiff ]
    ImgFilter->FLT_ABSDiff( g_img_FrameDiff,  g_Sobel_img , g_Sobel_imgPrev, ThdBinary ,imgDimensionX, imgDimensionY);

        /// CornerMap [ g_harrisMap ]

    ImgFilter->CntQty16x16(CTAMinorBlockL_EdgeQuantity, g_img_FrameDiff, imgDimensionX, imgDimensionY, 
                           RegionL[0], RegionL[1], RegionL[2], RegionL[3], 0);
    
    ImgFilter->CntQty16x16(CTAMinorBlockR_EdgeQuantity, g_img_FrameDiff, imgDimensionX, imgDimensionY, 
                           RegionR[0], RegionR[1], RegionR[2], RegionR[3], 0);            

    ImgFilter->CntQty16x16(g_HSobelQty16x16, g_hSobel_img, imgDimensionX, imgDimensionY,
                           0, RegionL[1], imgDimensionX, RegionL[3], THD_SobelEdge); 
    ImgFilter->CntQty16x16(g_VSobelQty16x16, g_vSobel_img, imgDimensionX, imgDimensionY,
                           0, RegionL[1], imgDimensionX, RegionL[3], THD_SobelEdge );

    /// Binarilize Image of V channel of HSV [ g_bin_img ]    
    ImgFilter->ImageThreshold_01( g_bin_img, g_Gaussian_img, imgDimensionX, imgDimensionY, THD_Binary );

  
#   pragma endregion    
#   else // for K2 platform
    
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif    
    
    ICP_Image_ROI roi;    
    LIB_RESULT lib_ret;
    
    roi.xOffset = 0;
    roi.yOffset = RegionL[1];
    roi.width = imgDimensionX;
    roi.height = RegionL[3] - RegionL[1];

    lib_ret = gicp_roi_SrcY.Create(picp_src_Y, &roi, 0);
                       
    APEX_CTA_DayProcess_Start(&gicp_roi_SrcY, pROI_Gaussian, pROI_Sobel, pROI_SobelPrev, 
                              pROI_hSobel, pROI_vSobel, pROI_FrameDiff, pROI_bin,
                              ThdBinary, THD_Binary);    
    APEX_CTA_DayProcess_Wait();

    gicp_roi_SrcY.Destroy();

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) APEX_CTA_DayProcess_Start(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif    


#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif    

    APEX_CTA_HarrisCorner_Start(pROI_hSobel, pROI_vSobel, pROI_Gaussian, pROI_FrameDiff, pROI_harrisMap, TH, e_value);
    APEX_CTA_HarrisCorner_Wait();        

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) APEX_CTA_HarrisCorner_Start: %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif

#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif    

    APEX_CTA_CntSobelQty16x16_Start(pROI_hSobel, &gicp_HSobelQty16x16, THD_SobelEdge);
    APEX_CTA_CntSobelQty16x16_Wait();

    APEX_CTA_CntSobelQty16x16_Start(pROI_vSobel, &gicp_VSobelQty16x16, THD_SobelEdge);
    APEX_CTA_CntSobelQty16x16_Wait();

    roi.xOffset = 0;
    roi.width = imgDimensionX/2;
    lib_ret = gicp_roi_left.Create(&gicp_FrameDiff, &roi, 0);
    
    roi.xOffset = imgDimensionX/2;
    lib_ret = gicp_roi_right.Create(&gicp_FrameDiff, &roi, 0);

    APEX_CTA_CntEdgeQty16x16_Start(&gicp_roi_left, &gicp_CTAMinorBlockL_EdgeQuantity);
    APEX_CTA_CntEdgeQty16x16_Wait();
    
    APEX_CTA_CntEdgeQty16x16_Start(&gicp_roi_right, &gicp_CTAMinorBlockR_EdgeQuantity);
    APEX_CTA_CntEdgeQty16x16_Wait();
    
    gicp_roi_left.Destroy();
    gicp_roi_right.Destroy();

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) APEX_CTA_CntEdgeQty16x16_Start: %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif

#   endif
    /// Data Save
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif       

    CTATargetNum.FeaturePtNum = CTAPatch->SaveCornerPos( g_harrisMap,imgDimensionX, imgDimensionY, harrisCorners, harrisCorners2, MAXSizeHarrisCorner);

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) CTAPatch->SaveCornerPos(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif    

    /// ==VERIFY== Plot Corners Informatio with GREEN COLOR
    // g_Gaussian_img  / g_Sobel_img / g_vSobel_img / g_hSobel_img /g_harrisValue / g_harrisMap
    verify_GaussianImg_HarrisCorner( dst_Y , g_Gaussian_img, g_harrisMap,g_Sobel_img,g_vSobel_img,g_hSobel_img,g_harrisValue, 
                                     g_VSobelQty16x16, g_HSobelQty16x16,
                                     CTATargetNum.FeaturePtNum , imgDimensionX , imgDimensionY );
    
    /// ==VERIFY== ABS Diff of Sobel Image with PURPLE COLOR
    verify_FLT_ABSDiff(dst_Y , imgDimensionX , imgDimensionY , g_img_FrameDiff,  g_Sobel_img , g_Sobel_imgPrev );

//    verify_APEX01_Night( dst_Y , imgDimensionX, imgDimensionY, g_bin_img );
    
#   ifdef _WIN32
    QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] );
#   endif
#   pragma region    ============Weather_Type============
    //CTAWeather = GetWheatherType(g_SrcY, imgDimensionX,imgDimensionY , CTATime.FrameNum , CTAWeather);
    CTAWeather = Day;//Night;

    /// ==VERIFY== Plot Weather Information
    verify_WeatherType( dst_Y , imgDimensionX, imgDimensionY, CTAWeather );

#   ifdef _WIN32
    QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] );//[2]
#   endif
#   pragma endregion 
    
    /// The CTA MODE
    if( Day == CTAWeather)
    {
        CTA_ProcessDay(dst_Y);
    }
    else if( Night == CTAWeather )
    {
        CTA_ProcessNight( dst_Y );
    } 

    verify_TimeCost( dst_Y , imgDimensionX ,imgDimensionY,CTATime , TicIdx );

#if _ENABLE_PROFILE_
    profile_idx++;
#endif
}

/**
* @brief  trigger to reset parameters, 
*/
void CTA_Reset(void)
{
    /**
    *@TODO: software trigger it , and Need Reset the parameter (not Release memory, NO call oTo_WorkBuf_Allocate/oTo_WorkBuf_Release) 
    */
    CTATime.FrameNum    = 1 ;
}
/**
* @brief Release Memory
*/
void CTA_WorkBuf_Release(void)
{

#ifdef _WIN32
    /// XML File Export.("C:\\CTA_Log\\CTA_Log.xml")
    CTALog->ExportCTALog_ALARM(VideoFilePath , EventResultL , EventResultR , MAXSizeEventResult);

    CTA_free(g_Sobel_img);
    CTA_free(g_vSobel_img);
    CTA_free(g_hSobel_img);
    //CTA_free(g_SobelEroded_img);
    //CTA_free(g_SobelEroded_imgPrev);
    CTA_free(g_tag);
    CTA_free(g_Gaussian_img);
    CTA_free(g_SrcY);
    CTA_free(g_Gaussian_imgPrev);
    CTA_free(g_harrisValue);
    CTA_free(g_harrisMap);
    CTA_free(g_harrisMapPrev);

    CTA_free(CTAMinorBlockL_EdgeQuantity);
    CTA_free(CTAMinorBlockR_EdgeQuantity);
    CTA_free(g_HSobelQty16x16);
    CTA_free(g_VSobelQty16x16);

    //-----[NightMode]
    CTA_free( g_bin_img );
    CTA_free( g_bin_PrevImg );
    CTA_free( harrisCorners);
    CTA_free( harrisCornersPrev);
    CTA_free( harrisCorners2);
    CTA_free( harrisCorners2Prev);
#else // for K2 platform
    // destroy ROI image
    gicp_roi_Gaussian.Destroy();
    gicp_roi_GaussianPrev.Destroy();
    gicp_roi_Sobel.Destroy();
    gicp_roi_SobelPrev.Destroy();
    gicp_roi_vSobel.Destroy();
    gicp_roi_hSobel.Destroy();
    gicp_roi_harrisMap.Destroy();
    gicp_roi_harrisMapPrev.Destroy();
    gicp_roi_FrameDiff.Destroy();
    gicp_roi_bin.Destroy();
    gicp_roi_binPrev.Destroy();

    // do not free allocated memory used in ICP_Image, since ICP_Image::Destory() will destory allocated memory automatically    
    gicp_Gaussian.Destroy();
    gicp_GaussianPrev.Destroy();
    gicp_Sobel.Destroy();
    gicp_SobelPrev.Destroy();
    gicp_vSobel.Destroy();
    gicp_hSobel.Destroy();
    //gicp_SobelEroded_img.Destroy();
    //gicp_SobelEroded_imgPrev.Destroy();        
    gicp_harrisMap.Destroy();
    gicp_harrisMapPrev.Destroy();
    gicp_FrameDiff.Destroy();
    gicp_bin.Destroy();
    gicp_binPrev.Destroy();   

    gicp_CTAMinorBlockL_EdgeQuantity.Destroy();
    gicp_CTAMinorBlockR_EdgeQuantity.Destroy();

    gicp_HSobelQty16x16.Destroy();
    gicp_VSobelQty16x16.Destroy();
#endif
}


//******************************************************************************
// F U N C T I O N   B O D Y S
//******************************************************************************

/**
*@brief	    [DayMode] CTA Process
*@param[in] dst_Y			the YCbCr ImgData show in
*/
static void CTA_ProcessDay(UCHAR *dst_Y)
{
#       pragma region ============POINT_TRACKING============
        //  p_th_array[i]
        //  0 : if SAD > the value, moving is too large
        //  1 : if Diff(SAD, original point)< the value, assign moving value 
        //  2 : if SAD < the value, moving is too small 
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif
        CONST INT32	p_th_array[3]     = { 200<<2 , -999 , -999 }; ///< Threshold [0] targetTH [1] sad_diff_TH [2] zero_motion_sad_TH
        CONST INT32 MATCH_SHIFT_BIT   =  0;						  ///<  ">>MATCH_SHIFT_BIT
        TRACK->setPara( p_th_array , MATCH_SHIFT_BIT , RegionL , RegionR );

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) TRACK->setPara(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif

#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif       
        TRACK->CornersMotionEstimation(harrisCornersPrev, harrisCorners2Prev, g_Gaussian_img, g_Gaussian_imgPrev, imgDimensionX, CTATargetNum.FeaturePtNumPrev);
#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) TRACK->CornersMotionEstimation(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif
        
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif
        
        TRACK->PointTrackPatch(harrisCornersPrev, harrisCorners2Prev, g_Gaussian_img, imgDimensionX, carSpec, carState,
                               CTATargetNum.FeaturePtNumPrev);
#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) TRACK->PointTrackPatch(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif

        /// ==VERIFY== PLOT Optical flow[Yellow]/ speed compensation flow[Red]
        verify_MotionCorner(dst_Y , imgDimensionX , imgDimensionY , harrisCornersPrev, harrisCorners2Prev, RegionL ,RegionR, 
                            CTATargetNum.FeaturePtNumPrev);
#       ifdef _WIN32
        QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] );
#       endif
#       pragma endregion 
#       pragma region ============POINT_GROUPING============
        // THD_MinorBlockUpdate[i1]
        // 0 :	THD_MotionEdgeQ     = 1;
        // 1 :  THD_MotionVectorQ   = 2;
        // 2 :  THD_MotionVectorDir = (FLOAT)0.9; /// the ratio of 2 most dir >90% 
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif    

        CONST DOUBLE THD_MinorBlockUpdate[3] = { 10 , 3 , 0.89 };
        Cluster->MinorBlockUpdate(	CTAMinorBlockL , 
                                    CTAMinorBlockL_EdgeQuantity,
                                    RegionL,
                                    g_img_FrameDiff, 
                                    harrisCornersPrev, 
                                    harrisCorners2Prev,
                                    imgDimensionX, imgDimensionY,
                                    THD_MinorBlockUpdate,
                                    CTATargetNum.FeaturePtNumPrev);			///< MinorBlockType1 的個數
        Cluster->MinorBlockUpdate(	CTAMinorBlockR , 
                                    CTAMinorBlockR_EdgeQuantity,
                                    RegionR,
                                    g_img_FrameDiff, 
                                    harrisCornersPrev, 
                                    harrisCorners2Prev,
                                    imgDimensionX, imgDimensionY,
                                    THD_MinorBlockUpdate,
                                    CTATargetNum.FeaturePtNumPrev);
#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) Cluster->MinorBlockUpdate(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif
                                    
        /// ==VERIFY== MinorBlockUpdate
        verify_MinorBlockUpdate(dst_Y , imgDimensionX , imgDimensionY , 
                                ROISegBlockV , ROISegBlockH, CTAMinorBlockL , CTAMinorBlockR , RegionL , RegionR);
        
        ///2) Labeling
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif         
        CTATargetNum._L_MaxCandNum = Cluster->MinorBlockLabeling( CTAMinorBlockL ); ///< Max Label Idx
        CTATargetNum._R_MaxCandNum = Cluster->MinorBlockLabeling( CTAMinorBlockR ); ///< Max Label Idx(ex.9 mean GroupID 1 - 9 may exist )

#if _ENABLE_PROFILE_
            // calculate profile time
            profile_time = GetTimeLength(tick, GetSystemTimeUS());
            printf("(Profile %d) Cluster->MinorBlockLabeling(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif
                                            
        /// ==VERIFY== Labeling
        verify_Labeling(dst_Y , imgDimensionX , imgDimensionY , 
                        ROISegBlockH , ROISegBlockV,
                        RegionL , RegionR,
                        CTATargetNum._L_MaxCandNum , CTATargetNum._R_MaxCandNum ,
                        CTAMinorBlockL , CTAMinorBlockR,
                        CTAMinorBlockL_EdgeQuantity, CTAMinorBlockR_EdgeQuantity);

        ///3)Find the Proper Candidate and Filter(I) Candidate contains correct motion
        // THD_CandidateUpdate[i1]
        // 0 :	THD_MotionEdgeQ     = 1;
        // 1 :  THD_MotionVectorQ   = 2;
        // 2 :  THD_MotionVectorInnerDir = 2.9; /// Motion(inner)/Motion(out) > 2.9
        // 3 :  THD_MotionVectorInnerDir = 1.6; for near camera use
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif    
       
        CONST FLOAT THD_CandidateUpdate[4] = { 20 , 7 , 2.9, 1.6 };
        CTATargetNum._L_CandNum = Cluster->CandidateUpdate( CTACandidateL , CTAMinorBlockL , CTAMinorBlockL_EdgeQuantity, CTACandidatePrevL , CTATargetNum._L_MaxCandNum , RegionL , imgDimensionX, THD_CandidateUpdate);
        CTATargetNum._R_CandNum = Cluster->CandidateUpdate( CTACandidateR , CTAMinorBlockR , CTAMinorBlockR_EdgeQuantity, CTACandidatePrevR , CTATargetNum._R_MaxCandNum , RegionR , imgDimensionX, THD_CandidateUpdate);

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) Cluster->CandidateUpdate(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif

        /// ==VERIFY== Plot Candidate Info ( Filter I )
        verify_CandidateUpdate( dst_Y , imgDimensionX , imgDimensionY , 
                                CTATargetNum._L_CandNum , CTATargetNum._R_CandNum , CTACandidateL , CTACandidateR );

#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif    
        
        Cluster->PointGroupPatch();
#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) Cluster->PointGroupPatch(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif
        
#       ifdef _WIN32
        QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] );
#       endif
#       pragma endregion 
#       pragma region    ============Feature_Extraction============
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif    

        CNN->CandidateFeatureUpdate_1(CTACandidateL , CTATargetNum._L_MaxCandNum ,g_vSobel_img, g_hSobel_img , g_img_FrameDiff,
        							  imgDimensionX, imgDimensionY, harrisCornersPrev, harrisCorners2Prev, CTATargetNum.FeaturePtNumPrev,
        							  g_VSobelQty16x16, g_HSobelQty16x16, CTAMinorBlockL_EdgeQuantity);
        CNN->CandidateFeatureUpdate_1(CTACandidateR , CTATargetNum._R_MaxCandNum ,g_vSobel_img, g_hSobel_img , g_img_FrameDiff,
        							  imgDimensionX , imgDimensionY , harrisCornersPrev, harrisCorners2Prev, CTATargetNum.FeaturePtNumPrev,
         							  g_VSobelQty16x16, g_HSobelQty16x16, CTAMinorBlockR_EdgeQuantity);

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) CNN->CandidateFeatureUpdate_1(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif

        verify_CandidateFeatureUpdate(g_Gaussian_img , imgDimensionX , imgDimensionY ,
                                      CTACandidateL , CTACandidateR );
#       pragma endregion 

#       pragma region    ============Machine_learning & Filter(2)============
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif              
        CTATargetNum._L_CandNum = CNN->Predict_1( CTACandidateL , CTATargetNum._L_MaxCandNum,CTATargetNum._L_CandNum );// Candidate 有效性 最終Filter
        CTATargetNum._R_CandNum = CNN->Predict_1( CTACandidateR , CTATargetNum._R_MaxCandNum,CTATargetNum._R_CandNum );

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) CNN->Predict_1(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif

        /// ==VERIFY== Candidate after FilterII
        verify_CNNPredict(dst_Y ,imgDimensionX,imgDimensionY,CTATargetNum._L_CandNum , CTATargetNum._R_CandNum,
                          CTACandidateL , CTACandidateR );
#       ifdef _WIN32
        QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] );
#       endif
#       pragma endregion ╮(￣▽ ￣)╭

#       pragma region ============Estimation(Relation Combination)============
        /// 1) Assign the Candidate Relationship
       
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif              
	// THD_RelatedCand[i1]
	// 0 :	= 14*1.5;   //REF to BlockSize
	// 1 :  = 0.3;		//overlapped area ratio at coming near
	// 1 :  = 0.3;		//overlapped area ratio at coming far
	//
        CONST FLOAT THD_RelatedCand[3] = { 0 , 0.6, 0.8 }; ///
        /*  THD_RetrieveObj[0] = 2: 
            THD_RetrieveObj[1] = 1: 
            THD_RetrieveObj[2] = 2: max edge tracking times=2
            THD_RetrieveObj[3] = 1: if tracking SAD is small enough, edge tracking times -=1
        */
        CONST INT16 THD_RetrieveObj[4]= { 5 , 5  , 3 ,  5 }; 

        UINT16 LinkNumL  = CTACanEstimation->CandAssociation(CTACandidateL ,CTATargetNum._L_MaxCandNum ,
                                        CTACandidatePrevL ,CTATargetNum._L_MaxCandNumPrev ,'L', THD_RelatedCand,THD_RetrieveObj ); 
        UINT16 LinkNumR  = CTACanEstimation->CandAssociation(CTACandidateR , CTATargetNum._R_MaxCandNum,
                                        CTACandidatePrevR ,CTATargetNum._R_MaxCandNumPrev ,'R', THD_RelatedCand,THD_RetrieveObj );

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) CTACanEstimation->CandAssociation(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif    

#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif              
        /// find all the T-1 cand position in T.(cand in T ignore)
        LinkNumL+=CTAPatch->EdgeTracking( CTACandidateL, CTACandidatePrevL, RegionL,'L', 
                                          g_Gaussian_img, g_Gaussian_imgPrev, g_Sobel_imgPrev, g_harrisMapPrev, 
                                          harrisCornersPrev, harrisCorners2Prev, 
                                          &CTATargetNum, THD_RetrieveObj, CTATargetNum._L_MaxCandNum, CTATargetNum._L_MaxCandNumPrev,imgDimensionX);
        LinkNumR+=CTAPatch->EdgeTracking( CTACandidateR, CTACandidatePrevR, RegionR,'R', 
                                          g_Gaussian_img , g_Gaussian_imgPrev, g_Sobel_imgPrev, g_harrisMapPrev, 
                                          harrisCornersPrev, harrisCorners2Prev, 
                                          &CTATargetNum, THD_RetrieveObj, CTATargetNum._R_MaxCandNum, CTATargetNum._R_MaxCandNumPrev, imgDimensionX);
#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) CTAPatch->EdgeTracking(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif    
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif              

        CTACanEstimation->MergeOverlappedCand( CTACandidateL ,CTACandidatePrevL, 'L',CTATargetNum._L_MaxCandNum );
        CTACanEstimation->MergeOverlappedCand( CTACandidateR ,CTACandidatePrevR, 'R',CTATargetNum._R_MaxCandNum );

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) CTACanEstimation->MergeOverlappedCand(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif    

        /// 2) Patch
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif              
        
        CTATargetNum._L_CandNum = CTAPatch->FilterAfterPredict( CTACandidateL, CTATargetNum._L_CandNum , CTACandidatePrevL , CTATargetNum._L_MaxCandNumPrev  );
        CTATargetNum._R_CandNum = CTAPatch->FilterAfterPredict( CTACandidateR, CTATargetNum._R_CandNum , CTACandidatePrevR , CTATargetNum._R_MaxCandNumPrev  );

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) CTAPatch->FilterAfterPredict(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif    

#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif              
	CTACanEstimation->UpdateBoundaryInfo( CTACandidateL ,'L',RegionL, CTATargetNum._L_MaxCandNum );
	CTACanEstimation->UpdateBoundaryInfo( CTACandidateR ,'R',RegionR, CTATargetNum._R_MaxCandNum );
#if _ENABLE_PROFILE_
	// calculate profile time
	profile_time = GetTimeLength(tick, GetSystemTimeUS());
	printf("(Profile %d) CTACanEstimation->UpdateBoundaryInfo(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif            

	//must be after "UpdateBoundaryInfo()"
	CTACanEstimation->EliminateCrossover( CTACandidateL , CTACandidateR, &CTATargetNum );

#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif              
        
        /// 3) User View: KeepFrame, Size , Speed , Position
        // THD_WeightSpeed
        // 0 : Weight_SmoothSpeed = 0.1; //  means (Weight)*PreFrame+(1-Weight)*CurFrame
        // 1 : Weight_SmoothPos   = 0.1; //  means (Weight)*PreFrame+(1-Weight)*CurFrame
        CONST FLOAT THD_WeightSpeed[2] = { 0.9 , 0.0 };// { 0.8 , 0.8 };
        CTACanEstimation->GetCandInfo( CTACandidateL ,CTATargetNum._L_MaxCandNum , CTACandidatePrevL , g_Sobel_img,g_Gaussian_img, imgDimensionX , THD_WeightSpeed,CTATime.fps,dst_Y );
        CTACanEstimation->GetCandInfo( CTACandidateR ,CTATargetNum._R_MaxCandNum , CTACandidatePrevR , g_Sobel_img,g_Gaussian_img, imgDimensionX , THD_WeightSpeed,CTATime.fps,dst_Y );

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) CTACanEstimation->GetCandInfo(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif    

#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif              
        CTACanEstimation->UpdateFlagTHD( CTACandidateL , CTACandidateR );

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) CTACanEstimation->UpdateFlagTHD(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif            

        /// ==VERIFY== [ Relation, GetObjInfo , UpdateFlag ] 
        verify_Estimation(	dst_Y ,imgDimensionX,imgDimensionY,RegionL,RegionR,
                            CTACandidateL , CTACandidateR ,
                            CTACandidatePrevL, CTACandidatePrevR,
                            CTACanEstimation->CountDownFlagAdpL,CTACanEstimation->CountDownFlagAdpR, 
                            &CTATargetNum);
#       ifdef _WIN32
        QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] );
#       endif
#       pragma endregion 
#       pragma region    ============Alarm_Strategy============ 
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif              

        CTADog->bawl( CTACandidateL, CTACandidateR, CTATargetNum._L_MaxCandNum, CTATargetNum._R_MaxCandNum, CTAAlarmState );

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) CTADog->bowwow(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif            

        /// ==VERIFY== CTADog[Draw (RED/YELLOW/WHITE)Rectanle][AudioWarnning/ImageWarnning]
        verify_CTADog( dst_Y ,imgDimensionX,imgDimensionY,RegionL,RegionR, CTACandidateL , CTACandidateR , CTAAlarmState , CTATime.FrameNum );
#       ifdef _WIN32
        QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] );
#       endif
#       pragma endregion 

#pragma region=======DumpData2RemoteCtrl=======
#ifdef _WIN32
		verify_DumpTrackingInfo(g_FrameReport,g_FrameReportIdx,CTACandidateL,CTACandidateR,&CTATargetNum);
#endif
#pragma endregion

        assert( "Update Data Before Next Frame" );
#if _ENABLE_PROFILE_
    tick = GetSystemTimeUS();
#endif              
        Update_Data_Before_Next_Frame(          CTACandidateL,CTACandidatePrevL,
                                                CTACandidateR,CTACandidatePrevR,CTATargetNum,
                                                CTATime.FrameNum, imgDimensionX,imgDimensionY );

#if _ENABLE_PROFILE_
    // calculate profile time
    profile_time = GetTimeLength(tick, GetSystemTimeUS());
    printf("(Profile %d) Update_Data_Before_Next_Frame(): %3u.%03u ms\n", profile_idx, profile_time/1000, profile_time%1000);
#endif            

        verify_Update_Data_Before_Next_Frame(   g_Gaussian_img,g_Gaussian_imgPrev,
                                                g_Sobel_img,g_Sobel_imgPrev,
                                                harrisCorners,harrisCornersPrev,
                                                harrisCorners2, harrisCorners2Prev,
                                                CTACandidateL,CTACandidatePrevL,
                                                CTACandidateR,CTACandidatePrevR,
                                                CTATime.FrameNum, imgDimensionX,imgDimensionY,
                                                &CTATargetNum);
#       ifdef _WIN32
        QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] );
#       endif
#       pragma endregion 
}
/**
*@brief	    [NightMode] CTA Process
*@param[in] dst_Y			the YCbCr ImgData show in
*/
static void CTA_ProcessNight(UCHAR *dst_Y)
{
#       pragma region    ============LightCluster_⊙▂⊙============
        /// Cluster to lampL/R
        Cluster->ClusterIntoHeadlight(g_bin_img, imgDimensionX, imgDimensionY,
                                      lampL , lampR ,
                                      CTATargetNum._L_MaxCandNum, CTATargetNum._R_MaxCandNum ,
                                      RegionL , RegionR);
        CTAPatch->Filter01_Night(g_bin_img, imgDimensionX, imgDimensionY,
                                 lampL , lampR ,
                                 CTATargetNum._L_MaxCandNum, CTATargetNum._R_MaxCandNum ,
                                 CTATargetNum._L_CandNum, CTATargetNum._R_CandNum ,
                                 RegionL , RegionR);

        /// ==VERIFY== [ show 1) HeadLight Number ] 
        verify_ClusterIntoHeadlight(dst_Y ,imgDimensionX,imgDimensionY,RegionL,RegionR,
                                    lampL , lampR ,
                                    CTATargetNum._L_MaxCandNum , CTATargetNum._R_MaxCandNum);
#       ifdef _WIN32
        QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] ); //[4]
#       endif // #ifdef _WIN32
#       pragma endregion ╮(￣▽ ￣)╭
#       pragma region    ============Headlight_Features_Extraction_└(^o^)┘============
        CNN->HeadLightFeatureUpdate_1( lampL , CTATargetNum._L_MaxCandNum);
        CNN->HeadLightFeatureUpdate_1( lampR , CTATargetNum._R_MaxCandNum);

        /// ==VERIFY== [ 1)Export Training data/img ] 
        verify_HeadLightFeatureUpdate_1( dst_Y , imgDimensionX ,imgDimensionY,RegionL,RegionR,
                                         lampL , lampR );
#       pragma endregion ╮(￣▽ ￣)╭
#       pragma region    ============Classifier_●▂●============
        CTATargetNum._L_CandNum = CNN->HeadLightPredict_1( lampL , CTATargetNum._L_MaxCandNum);
        CTATargetNum._R_CandNum = CNN->HeadLightPredict_1( lampR , CTATargetNum._R_MaxCandNum);

        /// ==VERIFY== [  lamp after Filter II ] 
        verify_HeadLightPredict_1( dst_Y , imgDimensionX ,imgDimensionY,RegionL,RegionR,
                                   lampL , lampR , CTATargetNum._L_CandNum , CTATargetNum._R_CandNum);
#       ifdef _WIN32
        QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] );
#       endif
#       pragma endregion ╮(￣▽ ￣)╭
#       pragma region    ====HeadlightEstimation[Association & Tracking & Grouping & LampInfo]_╯▂╰============
        /// 1) Association
        //  0: ex. 0.5 means 重疊區域>50%(0~1)
        //  1: ex. 3 means 面積scale比例介於 1/3<ratio<3
        CONST FLOAT THD_RelatedLamp[2] = { 0.2 , 3.0 }; ///< 符合"OverlapRatio(0-1)"與"大小(area)" 相似 的 Candidates
        UINT16 LinkNumL = CTACanEstimation->LampAssociation(lampL ,CTATargetNum._L_MaxCandNum, 
                                                            lampPrevL , CTATargetNum._L_MaxCandNumPrev , 
                                                            THD_RelatedLamp ); 
        UINT16 LinkNumR = CTACanEstimation->LampAssociation(lampR ,CTATargetNum._R_MaxCandNum, 
                                                            lampPrevR , CTATargetNum._L_MaxCandNumPrev , 
                                                            THD_RelatedLamp );
        ///2) Lamp Tracking 
        CTACanEstimation->LampSuperglue( lampPrevL,CTATargetNum._L_MaxCandNumPrev,
                                         lampL ,CTATargetNum._L_MaxCandNum,
                                         g_Gaussian_img , g_Gaussian_imgPrev, imgDimensionX);
        CTACanEstimation->LampSuperglue( lampPrevR,CTATargetNum._R_MaxCandNumPrev,
                                         lampR ,CTATargetNum._R_MaxCandNum,
                                         g_Gaussian_img , g_Gaussian_imgPrev, imgDimensionX);

        ///3) Lamps Grouping: pair two headlights into a group(car)
        // TODO: Not Ready yet

        ///4) lamp Info: [ Distance , distance from car head light to ground , speed , TTC ,(KeepFrame/Size) ]
        //      THD_WeightSpeed[0] = Weight_SmoothSpeed = 0.1; //  means (Weight)*CurFrame+(1-Weight)*PreFrame
        //      THD_WeightSpeed[1] = Weight_SmoothPos   = 0.1; //  means (Weight)*CurFrame+(1-Weight)*PreFrame
        CONST FLOAT THD_WeightSpeedPos[2] = { 0.2 , 0.5 };// { 0.0 , 0.0 };
        CTACanEstimation->GetLampInfo( g_bin_img, imgDimensionX, lampL , CTATargetNum._L_MaxCandNum, lampPrevL,CTATargetNum._L_MaxCandNumPrev ,CTATime.fps, THD_WeightSpeedPos );
        CTACanEstimation->GetLampInfo( g_bin_img, imgDimensionX, lampR , CTATargetNum._R_MaxCandNum, lampPrevR,CTATargetNum._R_MaxCandNumPrev ,CTATime.fps, THD_WeightSpeedPos );

        ///5) Flag Update
        //CTACanEstimation->UpdateFlagTHD_Night( lampL , lampR );

        /// ==VERIFY== [ Relation, GetLampInfo , UpdateFlagTHD_Night ] 
        verify_Estimation_Night( dst_Y ,imgDimensionX,imgDimensionY,RegionL,RegionR, 
                                 lampL , lampR ,
                                 lampPrevL, lampPrevR);
#       ifdef _WIN32        
        QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] );
#       endif // #ifdef _WIN32
#       pragma endregion ╮(￣▽ ￣)╭
#       pragma region    ============Warning_Decision_〒_〒.============
        CTADog->bowwow_Night( lampL ,lampPrevL, CTATargetNum._L_MaxCandNum, CTATargetNum._R_MaxCandNum, CTAAlarmState );
        
        /// ==VERIFY== CTADog(繪製obj- 黃/紅 框)[AudioWarnning/ImageWarnning]
        verify_CTADog_Night( dst_Y ,imgDimensionX,imgDimensionY,RegionL,RegionR, lampL , lampR , CTAAlarmState , CTATime.FrameNum);
#       ifdef _WIN32    
        QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] );
#       endif // #ifdef _WIN32
#       pragma endregion ╮(￣▽ ￣)╭
#       pragma region    ============Update Data Before Next Frame_〒_〒.鳴============
        Update_Data_Before_Next_Frame_Night(
                                            lampL,lampR,lampPrevL,lampPrevR, 
                                            CTATargetNum , 
                                            CTATime.FrameNum, imgDimensionX, imgDimensionY);

        verify_Update_Data_Before_Next_Frame_Night( g_Gaussian_img,g_Gaussian_imgPrev,
                                                    g_bin_img,g_bin_PrevImg,
                                                    lampL,lampPrevL,
                                                    lampR,lampPrevR,
                                                    CTATime.FrameNum, imgDimensionX,imgDimensionY);
#       ifdef _WIN32        
        QueryPerformanceCounter( &CTATime.TicCounter[TicIdx++] );
#       endif // #ifdef _WIN32
#       pragma endregion ╮(￣▽ ￣)╭
        
}

/**
*@brief   Return the CTA Left Target Cars Information & Numbers
*@param[out]  MaxNum    the MaxNum of Cars
*/
CandidateRec *GetResult_TargetCarsL( short &MaxNum )
{
    MaxNum = CTATargetNum._L_MaxCandNum ;
    return   CTACandidateL;
}

/**
*@brief   Return the CTA Right Target Cars Information & Numbers
*@param[out]  MaxNum    the MaxNum of Cars
*/
CandidateRec *GetResult_TargetCarsR( short &MaxNum )
{
    MaxNum = CTATargetNum._R_MaxCandNum;
    return   CTACandidateR;
}
/****************************END of CTA ***********************************************************/   
/*

                         測試中 ╭══╮  /○\ ◆　　　 ●
                              ╭╯ΘΘ║  /▓∨█\　　 /█\
        ==| █ ●_...○о o 。╰⊙═⊙╯   ∏　∏　　　 /\
*/

